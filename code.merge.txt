//DIR_TREE_START
{
  "CarrotLink.NET": {
    "CarrotLink.Client": {
      "_files": [
        "Program.cs"
      ]
    },
    "CarrotLink.Core": {
      "Devices": {
        "Configuration": {
          "_files": [
            "DeviceConfigurationBase.cs",
            "FtdiConfiguration.cs",
            "NiVisaConfiguration.cs",
            "SerialConfiguration.cs"
          ]
        },
        "Impl": {
          "_files": [
            "DeviceBase.cs",
            "FtdiDevice.cs",
            "NiVisaDevice.cs",
            "SerialDevice.cs"
          ]
        }
      },
      "Discovery": {
        "_files": [
          "DeviceDiscoveryService.cs",
          "DeviceSearcherFactory.cs"
        ],
        "Interfaces": {
          "_files": [
            "IDeviceSearcher.cs",
            "IDeviceSearcherFactory.cs"
          ]
        },
        "Models": {
          "_files": [
            "DeviceInfo.cs"
          ]
        },
        "Searchers": {
          "_files": [
            "FtdiSearcher.cs",
            "NiVisaSearcher.cs",
            "SerialSearcher.cs"
          ]
        }
      },
      "Protocols": {
        "Impl": {
          "_files": [
            "CarrotDataProtocol.cs",
            "IProtocolParser.cs",
            "ProtocolBase.cs",
            "RawAsciiProtocol.cs"
          ]
        },
        "Models": {
          "_files": [
            "BinaryPacket.cs",
            "CarrotDataProtocolPacket.cs",
            "IPacket.cs",
            "PacketBase.cs",
            "RawAsciiProtocolPacket.cs"
          ]
        }
      },
      "Services": {
        "_files": [
          "DevicePipelineService.cs",
          "DeviceServiceScheduler.cs"
        ],
        "Logging": {
          "_files": [
            "ConsoleLogger.cs",
            "ILogger.cs",
            "LoggerBase.cs"
          ]
        },
        "Storage": {
          "_files": [
            "ConcurrentStorageDecorator.cs",
            "IDataStorage.cs",
            "MemoryStorage.cs"
          ]
        }
      },
      "Utility": {
        "_files": [
          "AsciiEx.cs",
          "BytesEx.cs",
          "DriverErrorException.cs",
          "EscapeStringEx.cs",
          "JsonParser.cs",
          "NumEx.cs",
          "SerializationHelper.cs",
          "TimeoutDecorator.cs",
          "TraceHelper.cs"
        ]
      }
    },
    "CarrotLink.Native": {
      "_files": [
        "Class1.cs"
      ]
    },
    "CarrotLink.Old": {
      "CarrotCommFramework": {
        "Factory": {
          "_files": [
            "DriverFactory.cs",
            "LoggerFactory.cs",
            "ProductManager.cs",
            "ProductProvider.cs",
            "ProtocolFactory.cs",
            "ServiceFactory.cs",
            "SessionFactory.cs",
            "StreamFactory.cs"
          ]
        },
        "Services": {
          "_files": [
            "DataRecvService.cs",
            "ProtocolParseService.cs",
            "ServiceBase.cs",
            "SessionServiceBase.cs"
          ]
        },
        "Sessions": {
          "_files": [
            "Options.cs",
            "OptionsBuilder.cs",
            "Session.cs",
            "SessionConfigNameGenerater.cs"
          ]
        },
        "Streams": {
          "_files": [
            "BufferedStream.cs"
          ]
        }
      },
      "CarrotCommFrameworkDemo": {
        "_files": [
          "BatchWriter.cs",
          "Program.cs"
        ]
      }
    },
    "Library": {},
    "py": {}
  }
}
//DIR_TREE_END

//CarrotLink.Client/Program.cs
﻿using CarrotLink.Core.Devices.Impl;
using CarrotLink.Core.Services.Storage;
using CarrotLink.Core.Services;
using CarrotLink.Core.Devices.Configuration;
using CarrotLink.Core.Protocols;
using CarrotLink.Core.Protocols.Impl;

namespace CarrotLink.Client
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("Hello, World!");

            // 示例：完整设备操作流程
            var config = new SerialConfiguration
            {
                DeviceId = "Serial-COM3",
                PortName = "COM3",
                BaudRate = 115200,
            };
            var device = new SerialDevice(config);
            var storage = new MemoryStorage();
            var parser = new RawAsciiProtocol();
            await device.ConnectAsync();
            // 创建带线程安全的存储管道
            var pipeline = new DevicePipelineService(parser, new ConcurrentStorageDecorator(storage));
            _ = pipeline.StartProcessingAsync();
            // 定时读取数据
            /*
            var scheduler = new DeviceServiceScheduler(device);
            scheduler.StartAutoPolling(1000, data =>
            {
                pipeline.WriteToPipelineAsync(data).Wait();
                Console.WriteLine($"Received {data.Length} bytes");
            });
            */
            // 导出最终数据
            await storage.ExportAsJsonAsync("data.json", new { Timestamp = DateTime.Now });
        }
    }
}


//CarrotLink.Core/Devices/Configuration/DeviceConfigurationBase.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Devices.Configuration
{
    public abstract class DeviceConfigurationBase
    {
        public required string DeviceId { get; set; } = "<devid>";

        public int timeout { get; set; } = 5000;

        public virtual void Validate()
        {

        }
    }
}


//CarrotLink.Core/Devices/Configuration/FtdiConfiguration.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace CarrotLink.Core.Devices.Configuration
{
    /*
    public class FtdiConfiguration : DeviceConfigurationBase
    {
        public override void Validate()
        {
            base.Validate();
        }
    }
    */
}


//CarrotLink.Core/Devices/Configuration/NiVisaConfiguration.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace CarrotLink.Core.Devices.Configuration
{
    public class NiVisaConfiguration : DeviceConfigurationBase
    {
        public required string ResourceString { get; set; }
        public int ReadBufferSize { get; set; } = 4096;

        public override void Validate()
        {
            base.Validate();
        }
    }
}


//CarrotLink.Core/Devices/Configuration/SerialConfiguration.cs
﻿using System;
using System.Collections.Generic;
using System.IO.Ports;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace CarrotLink.Core.Devices.Configuration
{
    /// <summary>
    /// 串口校验位类型（兼容System.IO.Ports）
    /// </summary>
    [JsonConverter(typeof(JsonStringEnumConverter))]
    public enum SerialParity
    {
        None = Parity.None,
        Odd = Parity.Odd,
        Even = Parity.Even,
        Mark = Parity.Mark,
        Space = Parity.Space
    }

    /// <summary>
    /// 串口停止位类型
    /// </summary>
    [JsonConverter(typeof(JsonStringEnumConverter))]
    public enum SerialStopBits
    {
        One = StopBits.One,
        Two = StopBits.Two,
        OnePointFive = StopBits.OnePointFive
    }

    /// <summary>
    /// 串口设备配置（JSON示例：{"portName":"COM1","baudRate":115200,...}）
    /// </summary>
    public class SerialConfiguration : DeviceConfigurationBase
    {
        /// <summary>
        /// 串口号（必需）
        /// </summary>
        [JsonPropertyName("portName")]
        public required string PortName { get; init; }

        /// <summary>
        /// 波特率（默认115200）
        /// </summary>
        [JsonPropertyName("baudRate")]
        public int BaudRate { get; set; } = 115200;

        /// <summary>
        /// 数据位（默认8）
        /// </summary>
        [JsonPropertyName("dataBits")]
        public int DataBits { get; set; } = 8;

        /// <summary>
        /// 校验位（默认无）
        /// </summary>
        [JsonPropertyName("parity")]
        public SerialParity Parity { get; set; } = SerialParity.None;

        /// <summary>
        /// 停止位（默认1）
        /// </summary>
        [JsonPropertyName("stopBits")]
        public SerialStopBits StopBits { get; set; } = SerialStopBits.One;


        public override void Validate()
        {
            base.Validate();
        }
    }
}


//CarrotLink.Core/Devices/Impl/DeviceBase.cs
﻿using CarrotLink.Core.Devices.Configuration;
using System;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Devices.Impl
{
    public abstract class DeviceBase<TConfig> : IDisposable where TConfig : DeviceConfigurationBase
    {
        public TConfig Config { get; }
        public bool IsConnected { get; protected set; }

        public DeviceBase(TConfig config) => Config = config;

        public abstract Task ConnectAsync();
        public abstract Task DisconnectAsync();

        public abstract Task<int> ReadAsync(Memory<byte> buffer);

        public abstract Task WriteAsync(ReadOnlyMemory<byte> data);

        public virtual void Dispose() => DisconnectAsync().Wait();
    }
}


//CarrotLink.Core/Devices/Impl/FtdiDevice.cs
﻿using System;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.IO.Ports;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using FTD2XX_NET;
using static FTD2XX_NET.FTDI;
using System.Diagnostics;
using System.Net.NetworkInformation;
using System.Threading;
using CarrotLink.Core.Discovery.Searchers;
using CarrotLink.Core.Devices.Configuration;

namespace CarrotLink.Core.Devices.Impl
{
    /*
    public class FtdiDevice : DeviceBase
    {
        /// <summary>
        /// FTDI驱动包装类
        /// </summary>
        private FTDI Ftdi { get; set; }

        private int Timeout { get; set; } = 1000;

        private byte FtdiMask { get; set; }
        private byte FtdiMode { get; set; }

        private readonly FtdiConfiguration _config;

        public FtdiDevice(FtdiConfiguration config)
        {

            _config = config;
        }

        /// <summary>
        /// 流指示有数据
        /// </summary>
        public override bool ReadAvailable => Ftdi != null && Ftdi.IsOpen && GetBytesToRead() != 0;

        /// <summary>
        /// 关闭流
        /// </summary>
        public override void Close()
        {
            Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.Close());
        }

        /// <summary>
        /// 打开流
        /// </summary>
        public override void Open()
        {
            Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.OpenBySerialNumber("SerialNumber"));

            // Set Timeout
            Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.SetTimeouts((uint)Timeout, (uint)Timeout));

            // Set BitMode
            // SYNC FIFO MODE NEED BOTH WRITE EEPROM AND SETBITMODE
            byte mask, mode;
            mask = 0xff;
            //   BitMode:
            //     For FT232H devices, valid values are FT_BIT_MODE_RESET, FT_BIT_MODE_ASYNC_BITBANG, FT_BIT_MODE_MPSSE, FT_BIT_MODE_SYNC_BITBANG, FT_BIT_MODE_CBUS_BITBANG, FT_BIT_MODE_MCU_HOST, FT_BIT_MODE_FAST_SERIAL, FT_BIT_MODE_SYNC_FIFO.
            //     For FT2232H devices, valid values are FT_BIT_MODE_RESET, FT_BIT_MODE_ASYNC_BITBANG, FT_BIT_MODE_MPSSE, FT_BIT_MODE_SYNC_BITBANG, FT_BIT_MODE_MCU_HOST, FT_BIT_MODE_FAST_SERIAL, FT_BIT_MODE_SYNC_FIFO.
            //     For FT4232H devices, valid values are FT_BIT_MODE_RESET, FT_BIT_MODE_ASYNC_BITBANG, FT_BIT_MODE_MPSSE, FT_BIT_MODE_SYNC_BITBANG.
            //     For FT232R devices, valid values are FT_BIT_MODE_RESET, FT_BIT_MODE_ASYNC_BITBANG, FT_BIT_MODE_SYNC_BITBANG, FT_BIT_MODE_CBUS_BITBANG.
            //     For FT245R devices, valid values are FT_BIT_MODE_RESET, FT_BIT_MODE_ASYNC_BITBANG, FT_BIT_MODE_SYNC_BITBANG.
            //     For FT2232 devices, valid values are FT_BIT_MODE_RESET, FT_BIT_MODE_ASYNC_BITBANG, FT_BIT_MODE_MPSSE, FT_BIT_MODE_SYNC_BITBANG, FT_BIT_MODE_MCU_HOST, FT_BIT_MODE_FAST_SERIAL.
            //     For FT232B and FT245B devices, valid values are FT_BIT_MODE_RESET, FT_BIT_MODE_ASYNC_BITBANG.
            mode = FT_BIT_MODES.FT_BIT_MODE_SYNC_FIFO;
            Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.SetBitMode(mask, mode));


            Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.Purge(FT_PURGE.FT_PURGE_RX & FT_PURGE.FT_PURGE_TX));
        }

        /// <summary>
        /// 流写入
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            WriteInternal(buffer, offset, count);
        }

        /// <summary>
        /// 流读取
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            return ReadInternal(buffer, offset, count);
        }

        private void WriteInternal(byte[] buffer, int offset, int count)
        {
            byte[] bufferWithZeroOffset = buffer;
            uint numBytesWritten = 0;
            if (offset != 0)
            {
                bufferWithZeroOffset = buffer.Skip(offset).ToArray();
            }

            Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.Write(bufferWithZeroOffset, count, ref numBytesWritten));

            // Waiting for transfer done
            // TODO 同步流写入存在阻塞，待优化
            while (count != numBytesWritten)
            {
                Debug.WriteLine($"Waiting for write device done ({numBytesWritten}/{count})");
            }
        }

        private int ReadInternal(byte[] buffer, int offset, int bytesExpected)
        {
            uint currentBytesRead = 0;
            uint currentBytesExpected = 0;
            int totalBytesRead = 0;
            byte[] rx = new byte[Math.Min(bytesExpected, 1048576)];

            int BytesToRead = GetBytesToRead();
            bytesExpected = BytesToRead > bytesExpected ? bytesExpected : BytesToRead;

            while (bytesExpected > 0)
            {
                // 一次读取不超过读取缓冲区的长度字节流
                currentBytesExpected = (uint)bytesExpected;
                currentBytesExpected = rx.Length > currentBytesExpected ? currentBytesExpected : (uint)rx.Length;

                // Read
                Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.Read(rx, currentBytesExpected, ref currentBytesRead));

                // Copy to Buffer
                Array.Copy(rx, 0, buffer, offset, currentBytesRead);

                offset += (int)currentBytesRead;
                totalBytesRead += (int)currentBytesRead;
                bytesExpected -= (int)currentBytesRead;
            }
            return totalBytesRead;
        }

        private int GetBytesToRead()
        {
            uint rxQuene = 0;
            Ftd2xxNetDecorator.Ftd2xxNetWrapper(() => Ftdi.GetRxBytesAvailable(ref rxQuene));
            return (int)rxQuene;
        }
    }
    */
}


//CarrotLink.Core/Devices/Impl/NiVisaDevice.cs
﻿using System;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.IO.Ports;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using NationalInstruments.VisaNS;
using System.Diagnostics;
using CarrotLink.Core.Devices.Configuration;

namespace CarrotLink.Core.Devices.Impl
{
    /*
    public class NiVisaDevice : DeviceBase
    {

        /// <summary>
        /// 流指示有数据
        /// </summary>
        public override bool ReadAvailable
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        /// <summary>
        /// 驱动层实现
        /// </summary>
        protected MessageBasedSession Session { get; set; }

        private readonly NiVisaConfiguration _config;

        public NiVisaDevice(NiVisaConfiguration config)
        {
            _config = config;
        }

        /// <summary>
        /// 关闭流
        /// </summary>
        public override void Close()
        {
        }

        /// <summary>
        /// 打开流
        /// </summary>
        public override void Open()
        {
            var res = (MessageBasedSession)ResourceManager.GetLocalManager().Open("ADDR");
            if (res is MessageBasedSession)
                Session = res;
            else
                throw new Exception();

            Session.Timeout = 30000;
        }

        /// <summary>
        /// 流写入
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            byte[] bytes = new byte[count];
            Array.Copy(buffer, offset, bytes, 0, count);
            Session.Write(buffer);
        }

        /// <summary>
        /// 流读取
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            try
            {
                byte[] x = Session.ReadByteArray(count);
                Array.Copy(x, 0, buffer, offset, x.Length);
                return x.Length;
            }
            catch
            {
                return 0;
            }
        }
    }
    */
}


//CarrotLink.Core/Devices/Impl/SerialDevice.cs
﻿using System;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.IO.Ports;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using CarrotLink.Core.Devices.Configuration;
using NationalInstruments.DataInfrastructure;

namespace CarrotLink.Core.Devices.Impl
{
    public class SerialDevice : DeviceBase<SerialConfiguration>
    {
        /// <summary>
        /// 驱动层实现
        /// </summary>
        private SerialPort? _serialPort;

        public SerialDevice(SerialConfiguration config) : base(config) { }

        public override async Task ConnectAsync()
        {
            _serialPort = new SerialPort(
                portName: Config.PortName,
                baudRate: Config.BaudRate,
                parity: (Parity)Config.Parity,
                dataBits: Config.DataBits,
                stopBits: (StopBits)Config.StopBits);
            _serialPort.Open();
            IsConnected = true;
            await Task.CompletedTask;
        }

        public override async Task DisconnectAsync()
        {
            if (_serialPort != null && _serialPort.IsOpen)
            {
                _serialPort.Close();
                IsConnected = false;
            }
            await Task.CompletedTask;
        }

        public override async Task<int> ReadAsync(Memory<byte> buffer)
        {
            if (_serialPort == null)
                throw new InvalidOperationException("Device not connected");
            return await _serialPort.BaseStream.ReadAsync(buffer);
        }

        public override async Task WriteAsync(ReadOnlyMemory<byte> data)
        {
            if (_serialPort == null)
                throw new InvalidOperationException("Device not connected");
            await _serialPort.BaseStream.WriteAsync(data);
        }
    }
}


//CarrotLink.Core/Discovery/DeviceDiscoveryService.cs
﻿using CarrotLink.Core.Discovery.Interfaces;
using CarrotLink.Core.Discovery.Models;

namespace CarrotLink.Core.Discovery
{
    public class DeviceDiscoveryService
    {
        private readonly IDeviceSearcherFactory _factory;

        public DeviceDiscoveryService(IDeviceSearcherFactory factory)
        {
            _factory = factory;
        }

        public IEnumerable<DeviceInfo> DiscoverDevices(DeviceType type)
        {
            var searcher = _factory.GetSearcher(type);
            return searcher.Search();
        }

        public Dictionary<DeviceType, IEnumerable<DeviceInfo>> DiscoverAll()
        {
            return Enum.GetValues(typeof(DeviceType))
                .Cast<DeviceType>()
                .ToDictionary(
                    type => type,
                    type => DiscoverDevices(type)
                );
        }
    }
}

//CarrotLink.Core/Discovery/DeviceSearcherFactory.cs
﻿using CarrotLink.Core.Discovery.Interfaces;
using CarrotLink.Core.Discovery.Models;
using CarrotLink.Core.Discovery.Searchers;

namespace CarrotLink.Core.Discovery
{
    public class DeviceSearcherFactory : IDeviceSearcherFactory
    {
        private readonly Dictionary<DeviceType, IDeviceSearcher> _searchers;

        public DeviceSearcherFactory()
        {
            _searchers = new Dictionary<DeviceType, IDeviceSearcher> {
                [DeviceType.SerialPort] = new SerialSearcher(),
                [DeviceType.Gpib] = new NiVisaSearcher(),
                [DeviceType.Ft2232] = new FtdiSearcher()
            };
        }

        public IDeviceSearcher GetSearcher(DeviceType type)
        {
            if (_searchers.TryGetValue(type, out var searcher))
                return searcher;

            throw new NotSupportedException($"Unsupported device type: {type}");
        }
    }
}

//CarrotLink.Core/Discovery/Interfaces/IDeviceSearcher.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CarrotLink.Core.Discovery.Models;

namespace CarrotLink.Core.Discovery.Interfaces
{
    public interface IDeviceSearcher
    {
        /// <summary>
        /// 支持的设备类型
        /// </summary>
        DeviceType SupportedType { get; }

        /// <summary>
        /// 搜索可用设备
        /// </summary>
        IEnumerable<DeviceInfo> Search();
    }
}


//CarrotLink.Core/Discovery/Interfaces/IDeviceSearcherFactory.cs
﻿
using CarrotLink.Core.Discovery.Models;

namespace CarrotLink.Core.Discovery.Interfaces
{
    public interface IDeviceSearcherFactory
    {
        IDeviceSearcher GetSearcher(DeviceType type);
    }
}

//CarrotLink.Core/Discovery/Models/DeviceInfo.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Discovery.Models
{
    public enum DeviceType
    {
        SerialPort,
        Gpib,
        Ft2232
    }

    /// <summary>
    /// 设备信息
    /// </summary>
    public class DeviceInfo
    {
        public string Interface { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
    }
}


//CarrotLink.Core/Discovery/Searchers/FtdiSearcher.cs
﻿using FTD2XX_NET;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Ports;
using System.Linq;
using System.Net.NetworkInformation;
using System.Text;
using System.Threading.Tasks;
using static FTD2XX_NET.FTDI;
using static CarrotLink.Core.Discovery.Searchers.Ftd2xxNetDecorator;
using CarrotLink.Core.Utility;
using CarrotLink.Core.Discovery.Models;
using CarrotLink.Core.Discovery.Interfaces;

namespace CarrotLink.Core.Discovery.Searchers
{
    public class Ftd2xxException : Exception
    {
        public Ftd2xxException(FT_STATUS ftStatus) : base(ftStatus.ToString()) { }
        public Ftd2xxException(string ftStatus, Exception innerException) : base(ftStatus.ToString(), innerException) { }
    }

    public static class Ftd2xxNetDecorator
    {
        public static void Ftd2xxNetWrapper(Func<FT_STATUS> func, int timeout = 1000)
        {
            try
            {
                FT_STATUS ftStatus = TimeoutDecorator.TimeoutWrapper(func, timeout);
                if (ftStatus != FT_STATUS.FT_OK)
                {
                    throw new Ftd2xxException(ftStatus);
                }
            }
            catch (Exception ex)
            {
                throw new Ftd2xxException("Ftd2xxNetWrapper", ex);
            }
        }

    }

    public class FtdiSearcher : IDeviceSearcher
    {
        public DeviceType SupportedType => DeviceType.Ft2232;
        public FtdiSearcher()
        {
        }

        public IEnumerable<DeviceInfo> Search()
        {
            uint ftdiDeviceCount = 0;

            FTDI ftdi = new FTDI();
            Debug.WriteLine(Path.GetDirectoryName(GetType().Assembly.Location));


            // Determine the number of FTDI devices connected to the machine
            try
            {
                Ftd2xxNetWrapper(() => ftdi.GetNumberOfDevices(ref ftdiDeviceCount), 100);

                // Allocate storage for device info list
                FT_DEVICE_INFO_NODE[] ftdiDeviceList = new FT_DEVICE_INFO_NODE[ftdiDeviceCount];

                // Populate our device list
                Ftd2xxNetWrapper(() => ftdi.GetDeviceList(ftdiDeviceList), 100);

                for (uint i = 0; i < ftdiDeviceCount; i++)
                {
                    Debug.WriteLine("Device Index: " + i.ToString());
                    Debug.WriteLine("Flags: " + string.Format("{0:x}", ftdiDeviceList[i].Flags));
                    Debug.WriteLine("Type: " + ftdiDeviceList[i].Type.ToString());
                    Debug.WriteLine("ID: " + string.Format("{0:x}", ftdiDeviceList[i].ID));
                    Debug.WriteLine("Location ID: " + string.Format("{0:x}", ftdiDeviceList[i].LocId));
                    Debug.WriteLine("Serial Number: " + ftdiDeviceList[i].SerialNumber.ToString());
                    Debug.WriteLine("Description: " + ftdiDeviceList[i].Description.ToString());
                    Debug.WriteLine("");
                }
                return ftdiDeviceList.Select(dev => new DeviceInfo(/*"FTDI", dev.SerialNumber, dev.Description*/))
                    .ToArray();
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
                return [];
            }
        }
    }
}


//CarrotLink.Core/Discovery/Searchers/NiVisaSearcher.cs
﻿using CarrotLink.Core.Discovery.Interfaces;
using CarrotLink.Core.Discovery.Models;
using NationalInstruments.VisaNS;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Discovery.Searchers
{
    public class NiVisaSearcher : IDeviceSearcher
    {
        public DeviceType SupportedType => DeviceType.Gpib;
        public NiVisaSearcher()
        {
        }

        public IEnumerable<DeviceInfo> Search()
        {
            try
            {
                string expression = "?*";
                //string expression = "GPIB?*INSTR";
                string[] res = ResourceManager.GetLocalManager().FindResources(expression);
                return res.Select(d => new DeviceInfo(/*"VISA", d, "NI-VISA DEVICE"*/)).ToArray();
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
                return Array.Empty<DeviceInfo>();
            }
        }
    }
}


//CarrotLink.Core/Discovery/Searchers/SerialSearcher.cs
﻿using System;
using System.Collections.Generic;
using System.IO.Ports;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using CarrotLink.Core.Discovery.Interfaces;
using CarrotLink.Core.Discovery.Models;

namespace CarrotLink.Core.Discovery.Searchers
{
    public class SerialSearcher : IDeviceSearcher
    {
        public DeviceType SupportedType => DeviceType.SerialPort;


        public SerialSearcher()
        {
        }


        public IEnumerable<DeviceInfo> Search()
        {
            return SerialPort.GetPortNames().Select(d => new DeviceInfo(/*"COM", d, "串口设备"*/)).ToArray();
            //return
            //[
            //    new DeviceInfo("COM","200","SERIALPORT COM200 FOR TEST"),
            //    new DeviceInfo("COM","201","SERIALPORT COM201 FOR TEST")
            //];
        }
    }
}


//CarrotLink.Core/Protocols/Impl/CarrotDataProtocol.cs
﻿using CarrotLink.Core.Protocols.Models;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static CarrotLink.Core.Protocols.Models.CarrotDataProtocolPacket;

namespace CarrotLink.Core.Protocols.Impl
{
    public class CarrotDataProtocol : ProtocolBase
    {
        public static new string Version { get; } = "CDPV1";

        public CarrotDataProtocol()
        {
        }

        protected override bool TryDecode(ref ReadOnlySequence<byte> buffer, out PacketBase? packet)
        {
            packet = null;
            SequenceReader<byte> reader = new SequenceReader<byte>(buffer);
            int packetLen = 0;

            // 处理数据流直到不完整包或结束
            while (true)
            {
                // 读取帧头
                if ((reader.Remaining < 1) || (!reader.TryPeek(0, out byte frameStart)))
                {
                    // 不完整包结构则结束
                    break;
                    //return false;
                }
                if ((reader.Remaining < 2) || (!reader.TryPeek(1, out byte protocolId)))
                {
                    // 不完整包结构则结束
                    break;
                    //return false;
                }
                if (GetPacketLength(protocolId) == -1)
                {
                    break;
                }
                if ((reader.Remaining < packetLen) || (!reader.TryPeek(packetLen - 1, out byte frameEnd)))
                {
                    // 不完整包结构则结束
                    break;
                    //return false;
                }

                var x = reader.TryReadExact(packetLen, out var pktSeq);
                if (x)
                {
                    CarrotDataProtocolPacket pkt = new(pktSeq.ToArray());
                    switch (GetCdpType(pkt.ProtocolId!.Value))
                    {
                        case CDP_TYPE.DATA:
                            pkt = new CdpDataPacket(pkt);
                            break;
                        case CDP_TYPE.ASCII:
                            pkt = new CdpMessagePacket(pkt);
                            break;
                        case CDP_TYPE.REG:
                            pkt = new CdpRegisterPacket(pkt);
                            break;
                        default:
                            break;
                    }
                    buffer = buffer.Slice(buffer.GetPosition(packetLen));
                    packet = pkt;
                    break;
                }
            }
            return packet != null;
        }

    }
}


//CarrotLink.Core/Protocols/Impl/IProtocolParser.cs
﻿using CarrotLink.Core.Protocols.Models;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Protocols.Impl
{
    public interface IProtocolParser
    {
        public string Name { get; set; }
        public static string Version { get; }
        public bool TryParse(ref ReadOnlySequence<byte> buffer, out PacketBase? packet);
    }
}


//CarrotLink.Core/Protocols/Impl/ProtocolBase.cs
﻿using CarrotLink.Core.Protocols.Models;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Protocols.Impl
{
    /// <summary>
    /// 协议基类
    /// </summary>
    public abstract class ProtocolBase : IProtocolParser
    {
        public static string Version { get; set; } = nameof(ProtocolBase);
        public string Name { get; set; }

        protected abstract bool TryDecode(ref ReadOnlySequence<byte> buffer, out PacketBase? packet);

        public bool TryParse(ref ReadOnlySequence<byte> buffer, out PacketBase? packet)
        {
            // 通用预处理（例如校验CRC）
            if (buffer.IsEmpty)
                throw new ArgumentException("Empty data");
            return TryDecode(ref buffer, out packet);
        }
    }
}


//CarrotLink.Core/Protocols/Impl/RawAsciiProtocol.cs
﻿using CarrotLink.Core.Protocols.Models;
using CarrotLink.Core.Utility;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace CarrotLink.Core.Protocols.Impl
{
    public class RawAsciiProtocol : ProtocolBase
    {
        private enum RawAsciiProtocolParseStatus
        {
            IDLE,
            XML_CMD_START,
            XML_CMD_WAIT_TAG_HEAD_OPEN,
            XML_CMD_WAIT_TAG_BIN_OPEN,
            XML_CMD_WAIT_TAG_BIN_CONTENT,
            XML_CMD_WAIT_TAG_CLOSE,
            XML_CMD_XML_ERROR,
            ASCII_CMD_WAIT_CRLF,
        }

        public new static string Version { get; } = "RAPV1";

        public RawAsciiProtocol()
        {
        }

        protected override bool TryDecode(ref ReadOnlySequence<byte> buffer, out PacketBase? packet)
        {
            packet = default;

            var dataOpenTag = "<data>";
            var headOpenTag = "<head>";
            var headCloseTag = "</head>";
            var binaryOpenTag = "<binary>";
            var bDataOpenTag = "<![BDATA[";
            var bDataCloseTag = "]]>";
            var binaryCloseTag = "</binary>";
            var dataCloseTag = "</data>";
            var crlf = "\r\n";

            var xmlCmdTagHeadOpenCompare = $"{dataOpenTag}{headOpenTag}".AsciiToBytes().AsSpan();
            var xmlCmdTagBinOpenCompare = $"{headCloseTag}{binaryOpenTag}{bDataOpenTag}".AsciiToBytes().AsSpan();
            var xmlCmdTagCloseCompare = $"{bDataCloseTag}{binaryCloseTag}{dataCloseTag}{crlf}".AsciiToBytes().AsSpan();
            var asciiCmdCrlfCompare = $"{crlf}".AsciiToBytes().AsSpan();


            var reader = new SequenceReader<byte>(buffer);


            // 处理数据流直到不完整包或结束
            if (!reader.TryPeek(out byte b))
                return false;
            if (b == '<')
            {
                // XML TAG COMMAND
                if (reader.Remaining < xmlCmdTagHeadOpenCompare.Length)
                    return false;
                if (!reader.IsNext(xmlCmdTagHeadOpenCompare, true))
                    return false;
                if (reader.Remaining < xmlCmdTagBinOpenCompare.Length)
                    return false;
                if (!reader.TryReadTo(out ReadOnlySequence<byte> seqHead, xmlCmdTagBinOpenCompare, true))
                    return false;

                // head generate
                //Console.WriteLine($"Read data head: {BytesEx.BytesToAscii(seqHead.ToArray()).ReplaceLineEndings("\\r\\n")}");
                string xmlString = "<head>" + BytesEx.BytesToAscii(seqHead.ToArray()) + "</head>";
                XmlDocument doc = new XmlDocument();
                doc.LoadXml(xmlString);
                XmlElement root = doc.DocumentElement;
                XmlNode node = root.SelectSingleNode("/head/len");

                int dataLen = Convert.ToInt32(node.InnerText);

                if (dataLen < 0)
                    return false;
                if (reader.Remaining < dataLen)
                    return false;
                if (!reader.TryReadExact(dataLen, out ReadOnlySequence<byte> seqBin))
                    return false;

                // packet generate
                //Console.WriteLine($"Read data binary: {BytesEx.BytesToAscii(seqBin.ToArray()).ReplaceLineEndings("\\r\\n")}");

                packet = new BinaryPacket(seqBin.ToArray());

                if (reader.Remaining < xmlCmdTagCloseCompare.Length)
                    return false;
                if (!reader.IsNext(xmlCmdTagCloseCompare, true))
                    return false;

                Console.WriteLine($"Read data head: {BytesEx.BytesToAscii(seqHead.ToArray()).ReplaceLineEndings("\\r\\n")}");
                Console.WriteLine($"Read data binary: {BytesEx.BytesToAscii(seqBin.ToArray()).ReplaceLineEndings("\\r\\n")}");
            }
            else
            {
                // COMMAND END WITH CRLF
                if (reader.Remaining < asciiCmdCrlfCompare.Length)
                    return false;
                if (!reader.TryReadTo(out ReadOnlySequence<byte> seqCmd, asciiCmdCrlfCompare, true))
                    return false;

                // packet generate
                Console.WriteLine($"Read command to CRLF: {BytesEx.BytesToAscii(seqCmd.ToArray()).ReplaceLineEndings("\\r\\n")}");

                packet = new RawAsciiProtocolPacket(seqCmd.ToArray());
            }
            buffer = reader.UnreadSequence;
            return true;
        }
    }
}


//CarrotLink.Core/Protocols/Models/BinaryPacket.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Protocols.Models
{
    /// <summary>
    /// 数据包
    /// </summary>
    public class BinaryPacket : PacketBase
    {
        /// <summary>
        /// 数据包可阅读信息
        /// </summary>
        public override string? Message => "BinaryPacket";

        public override byte? ProtocolId => null;
        public override byte? StreamId => null;

        public Dictionary<string,string> Desc { get; set; }

        /// <summary>
        /// 构造函数
        /// </summary>
        public BinaryPacket(byte[] bytes) : base(bytes)
        {
        }
    }
}


//CarrotLink.Core/Protocols/Models/CarrotDataProtocolPacket.cs
﻿using CarrotLink.Core.Utility;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Protocols.Models
{
    public enum CDP_TYPE
    {
        UNKNOWN = 0x00,
        ASCII = 0x30,
        DATA = 0x40,
        REG = 0xA0
    };


    public class CarrotDataProtocolPacket : PacketBase
    {
        public const byte CDP_PACKET_START_BYTE = 0x3C;
        public const byte CDP_PACKET_END_BYTE = 0x3E;

        public const byte ProtocolIdAsciiTransfer64 = 0x31;
        public const byte ProtocolIdAsciiTransfer256 = 0x32;
        public const byte ProtocolIdAsciiTransfer2048 = 0x33;
        public const byte ProtocolIdDataTransfer74 = 0x41;
        public const byte ProtocolIdDataTransfer266 = 0x42;
        public const byte ProtocolIdDataTransfer2058 = 0x43;
        public const byte ProtocolIdRegisterOper = 0xA0;
        public const byte ProtocolIdRegisterReply = 0xA8;

        public CarrotDataProtocolPacket() : base()
        {
        }

        public CarrotDataProtocolPacket(byte[] bytes) : base(bytes)
        {
        }

        public CarrotDataProtocolPacket(CarrotDataProtocolPacket packet) : base(packet.Bytes!)
        {

        }

        /// <summary>
        /// 预设协议长度
        /// </summary>
        /// <param name="ProtocolId"></param>
        /// <returns></returns>
        public static int GetPacketLength(byte protocolId)
        {
            return protocolId switch
            {

                ProtocolIdAsciiTransfer64 => 64,
                ProtocolIdAsciiTransfer256 => 256,
                ProtocolIdAsciiTransfer2048 => 2048,
                ProtocolIdDataTransfer74 => 64 + 10,
                ProtocolIdDataTransfer266 => 256 + 10,
                ProtocolIdDataTransfer2058 => 2048 + 10,
                ProtocolIdRegisterOper => 256,
                ProtocolIdRegisterReply => 256,
                _ => -1,
            };
        }

        public static CDP_TYPE GetCdpType(byte protocolId)
        {
            if (protocolId >= 0x30 && protocolId <= 0x3F)
                return CDP_TYPE.ASCII;
            else if (protocolId >= 0x40 && protocolId <= 0x4F)
                return CDP_TYPE.DATA;
            else if (protocolId >= 0xA0 && protocolId <= 0xAF)
                return CDP_TYPE.REG;
            else
                return CDP_TYPE.UNKNOWN;
        }

        /// <summary>
        /// 字节数组
        /// </summary>
        public override byte[]? Bytes { get; set; }

        /// <summary>
        /// 数据包可阅读信息
        /// </summary>
        public override string? Message => GetDisplayMessage();
        public override byte? ProtocolId => Bytes?[1];
        public override byte? StreamId => Bytes?[4];


        public string GetDisplayMessage()
        {
            if (ProtocolId is null)
                return "<NULL>";
            var type = GetCdpType(ProtocolId.Value);
            switch (type)
            {
                case CDP_TYPE.ASCII:
                    return $"{Payload.ToArray().BytesToAscii().ReplaceLineEndings("")}";
                case CDP_TYPE.DATA:
                    return $"<{PayloadLength} Bytes Data>";
                case CDP_TYPE.REG:
                    return $"{Payload.ToArray().BytesToHexString()}";
                default:
                    return $"<UNKNOWN>";
            }
        }

        public byte[] Pack(byte[] payload, byte? protocolId, byte? streamId)
        {
            int len = GetPacketLength((byte)protocolId);
            byte[] bytes = new byte[len];

            bytes[0] = CDP_PACKET_START_BYTE;
            bytes[1] = (byte)protocolId;
            //bytes[2] = (byte)ControlFlags;
            //bytes[3] = (byte)(ControlFlags >> 8);
            bytes[2] = 0x00;
            bytes[3] = 0x00;
            bytes[4] = (byte)streamId;
            bytes[5] = (byte)payload.Length;
            bytes[6] = (byte)(payload.Length >> 8);
            Array.Copy(payload, 0, bytes, 7, payload.Length);
            //bytes[^3] = (byte)Crc16;
            //bytes[^2] = (byte)(Crc16 >> 8);
            bytes[^3] = 0xFF;
            bytes[^2] = 0xFF;
            bytes[^1] = CDP_PACKET_END_BYTE;

            return bytes;
        }


        // TODO
        /// 以下为实现

        /// <summary>
        /// protocol layout index : [0:0]
        /// </summary>
        public byte? FrameStart => Bytes?[0];
        /// <summary>
        /// protocol layout index : [1:1]
        /// </summary>
        //public override byte ProtocolId => Bytes[1];
        /// <summary>
        /// protocol layout index : [2:3]
        /// </summary>
        public ushort? ControlFlags => Bytes == null ? null : (ushort)(Bytes[3] << 8 | Bytes[2]);
        /// <summary>
        /// protocol layout index : [4:4]
        /// </summary>
        //public override byte StreamId => Bytes[4];
        /// <summary>
        /// protocol layout index : [5:6]
        /// </summary>
        public int? PayloadLength => Bytes == null ? null : (ushort)(Bytes[6] << 8 | Bytes[5]);
        /// <summary>
        /// protocol layout index : [7:6+len]
        /// </summary>
        public ReadOnlySpan<byte> Payload => Bytes == null ? null : Bytes.AsSpan(7, PayloadLength.Value);
        /// <summary>
        /// CRC16/MODBUS
        /// protocol layout index : [7+len:8+len]
        /// </summary>
        public ushort? Crc16 => Bytes == null ? null : (ushort)(Bytes[^2] << 8 | Bytes[^3]);
        /// <summary>
        /// protocol layout index : [9+len:9+len]
        /// </summary>
        public byte? FrameEnd => Bytes?[^1];


    }


    public class CdpRegisterPacket : CarrotDataProtocolPacket, IRegisterPacket
    {
        public CdpRegisterPacket(int oper, int regfile, int addr, int data)
        {
            Bytes = Pack(Encode(oper, regfile, addr, data), ProtocolIdRegisterOper, 0);
        }

        public CdpRegisterPacket(CarrotDataProtocolPacket packet) : base(packet)
        {

        }

        public byte[] Encode(int oper, int regfile, int addr, int data)
        {
            byte[] payload = new byte[16];
            byte[] RwnBytes = oper.IntToBytes();
            byte[] RegfileBytes = regfile.IntToBytes();
            byte[] AddressBytes = addr.IntToBytes();
            byte[] ValueBytes = data.IntToBytes();
            Array.Copy(RwnBytes, 0, payload, 0, 4);
            Array.Copy(RegfileBytes, 0, payload, 4, 4);
            Array.Copy(AddressBytes, 0, payload, 8, 4);
            Array.Copy(ValueBytes, 0, payload, 12, 4);
            return payload;
        }

        public (int control, int regfile, int addr, int data) Decode(byte[] bytes)
        {
            throw new NotImplementedException();
        }
    }


    public class CdpMessagePacket : CarrotDataProtocolPacket, IMessagePacket
    {
        public CdpMessagePacket(string msg)
        {
            Bytes = Pack(Encode(msg), ProtocolIdAsciiTransfer256, 0);
        }

        public CdpMessagePacket(CarrotDataProtocolPacket packet) : base(packet)
        {

        }

        public byte[] Encode(string msg)
        {
            return msg.AsciiToBytes();
        }

        public string Decode(byte[] bytes)
        {
            throw new NotImplementedException();
        }

    }

    public class CdpDataPacket : CarrotDataProtocolPacket, IDataPacket
    {

        public CdpDataPacket(byte[] data)
        {
            Bytes = Pack(Encode(data), ProtocolIdAsciiTransfer256, 0);
        }

        public CdpDataPacket(CarrotDataProtocolPacket packet) : base(packet)
        {

        }

        public byte[] Encode(byte[] data)
        {
            return data;
        }

        public byte[] Decode(byte[] data)
        {
            return data;
        }

    }
}

//CarrotLink.Core/Protocols/Models/IPacket.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Protocols.Models
{
    public interface IMessagePacket
    {
        public byte[] Encode(string msg);

        public string Decode(byte[] bytes);
    }

    public interface IRegisterPacket
    {
        public byte[] Encode(int oper, int regfile, int addr, int data);

        public (int control, int regfile, int addr, int data) Decode(byte[] bytes);
    }

    public interface IDataPacket
    {
        public byte[] Encode(byte[] data);

        public byte[] Decode(byte[] data);
    }
}


//CarrotLink.Core/Protocols/Models/PacketBase.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Protocols.Models
{
    /// <summary>
    /// 数据包
    /// </summary>
    public class PacketBase
    {
        public static PacketBase Empty => new([]);

        /// <summary>
        /// 字节数组
        /// </summary>
        public virtual byte[]? Bytes { get; set; }

        /// <summary>
        /// 数据包可阅读信息
        /// </summary>
        public virtual string? Message => null;
        public virtual byte? ProtocolId => null;
        public virtual byte? StreamId => null;

        public PacketBase()
        {
        }

        /// <summary>
        /// 构造函数
        /// </summary>
        public PacketBase(byte[] bytes)
        {
            Bytes = bytes;
        }
    }
}


//CarrotLink.Core/Protocols/Models/RawAsciiProtocolPacket.cs
﻿using CarrotLink.Core.Utility;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Protocols.Models
{
    /// <summary>
    /// 数据包
    /// </summary>
    public class RawAsciiProtocolPacket : PacketBase, IMessagePacket
    {
        /// <summary>
        /// 数据包可阅读信息
        /// </summary>
        public override string? Message => Encoding.ASCII.GetString(Bytes).TrimEnd("\r\n".ToCharArray());

        public override byte? ProtocolId => null;
        public override byte? StreamId => null;

        /// <summary>
        /// 构造函数
        /// </summary>
        public RawAsciiProtocolPacket(byte[] bytes) : base(bytes)
        {
        }

        public RawAsciiProtocolPacket(string msg)
        {
            Bytes = Encode(msg);
        }

        public byte[] Encode(string msg)
        {
            byte[] packets = (msg + "\r\n").AsciiToBytes();

            return packets;
        }

        public string Decode(byte[] bytes)
        {
            throw new NotImplementedException();
        }
    }
}


//CarrotLink.Core/Services/DevicePipelineService.cs
﻿using CarrotLink.Core.Protocols.Impl;
using CarrotLink.Core.Protocols.Models;
using CarrotLink.Core.Services.Storage;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services
{
    public sealed class DevicePipelineService : IDisposable
    {
        private readonly Pipe _pipe = new Pipe();
        private readonly IProtocolParser _parser;
        private readonly IDataStorage _storage;
        private readonly MemoryPool<byte> _memoryPool = MemoryPool<byte>.Shared;
        private CancellationTokenSource _cts = new CancellationTokenSource();
        public DevicePipelineService(IProtocolParser parser, IDataStorage storage)
        {
            _parser = parser;
            _storage = storage;
        }
        public async Task StartProcessingAsync()
        {
            PipeReader? reader = _pipe.Reader;
            while (!_cts.IsCancellationRequested)
            {
                ReadResult readResult = await reader.ReadAsync(_cts.Token);
                foreach (var segment in readResult.Buffer)
                {
                    //_parser.TryParse(segment, out RawAsciiProtocolPacket parsedData);
                    //_storage.StoreInMemory(Encoding.UTF8.GetBytes(parsedData.ToString()));
                }
                reader.AdvanceTo(readResult.Buffer.End);
            }
        }
        public async Task WriteToPipelineAsync(byte[] data)
        {
            using IMemoryOwner<byte>? owner = _memoryPool.Rent(data.Length);
            data.CopyTo(owner.Memory.Span);
            await _pipe.Writer.WriteAsync(owner.Memory, _cts.Token);
        }
        public void Dispose() => _cts.Cancel();
    }
}


//CarrotLink.Core/Services/DeviceServiceScheduler.cs
﻿using CarrotLink.Core.Devices.Configuration;
using CarrotLink.Core.Devices.Impl;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services
{/// <summary>
 /// 支持手动/定时/事件三种触发模式的服务调度
 /// </summary>
    public class DeviceServiceScheduler
    {
        private readonly DeviceBase<DeviceConfigurationBase> _device;
        private Timer? _pollingTimer;
        public DeviceServiceScheduler(DeviceBase<DeviceConfigurationBase> device) => _device = device;

        /*
        // 手动触发模式
        public async Task<byte[]> ManualReadAsync()
        => await _device.ReadAsync(_device.Config.timeout);

        // 定时轮询模式
        public void StartAutoPolling(int intervalMs, Action<byte[]> callback)
        {
            _pollingTimer = new Timer(async _ =>
            {
                var data = await _device.ReadAsync(_device.Config.timeout);
                callback(data);
            }, null, 0, intervalMs);
        }

        // 事件触发模式（需设备支持硬件中断）
        public void RegisterEventTrigger(Action<byte[]> callback)
        {
            // 示例：假设设备有DataReceived事件
            if (_device is SerialDevice serialDevice)
                serialDevice.DataReceived += (sender, data) => callback(data);
        }
        */
    }
}


//CarrotLink.Core/Services/Logging/ConsoleLogger.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services.Logging
{
    public class ConsoleLogger : LoggerBase
    {
        public override void LogInfo(string message)
        => Console.WriteLine(FormatMessage("INFO", message));
        public override void LogError(string message, Exception? ex = null)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(FormatMessage("ERROR", $"{message} {ex?.Message}"));
            Console.ResetColor();
        }
        public override void LogDebug(string message)
        => Console.WriteLine(FormatMessage("DEBUG", message));
    }
}

//CarrotLink.Core/Services/Logging/ILogger.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services.Logging
{
    public interface ILogger
    {
        void LogInfo(string message);
        void LogError(string message, Exception? ex = null);
        void LogDebug(string message);
    }
}


//CarrotLink.Core/Services/Logging/LoggerBase.cs
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services.Logging
{
    public abstract class LoggerBase : ILogger
    {
        public abstract void LogInfo(string message);
        public abstract void LogError(string message, Exception? ex = null);
        public abstract void LogDebug(string message);
        protected string FormatMessage(string type, string message)
        => $"[{DateTime.Now:HH:mm:ss.fff}] {type.ToUpper()}: {message}";
    }
}


//CarrotLink.Core/Services/Storage/ConcurrentStorageDecorator.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services.Storage
{
    public class ConcurrentStorageDecorator : IDataStorage
    {
        public ConcurrentStorageDecorator(IDataStorage storage)
        {
        }

        public Task ExportAsCsvAsync(string filePath, IEnumerable<object> records)
        {
            throw new NotImplementedException();
        }

        public Task ExportAsJsonAsync(string filePath, object data)
        {
            throw new NotImplementedException();
        }

        public void StoreInMemory(byte[] data)
        {
            throw new NotImplementedException();
        }
    }
}


//CarrotLink.Core/Services/Storage/IDataStorage.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services.Storage
{
    public interface IDataStorage
    {
        void StoreInMemory(byte[] data);
        Task ExportAsJsonAsync(string filePath, object data);
        Task ExportAsCsvAsync(string filePath, IEnumerable<object> records);
    }
}


//CarrotLink.Core/Services/Storage/MemoryStorage.cs
﻿using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Services.Storage
{
    public class MemoryStorage : IDataStorage
    {
        private readonly ConcurrentQueue<byte[]> _buffer = new();

        public void StoreInMemory(byte[] data) => _buffer.Enqueue(data);

        public Task ExportAsJsonAsync(string filePath, object data)
        => throw new NotImplementedException();

        public Task ExportAsCsvAsync(string filePath, IEnumerable<object> records)
        => throw new NotImplementedException();
    }
}


//CarrotLink.Core/Utility/AsciiEx.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Utility
{
    public static class AsciiEx
    {
        /// <summary>
        /// 检测是否为可打印字符
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static bool IsPrintableAscii(this char c)
        {
            return c >= (char)0x20 && c <= (char)0x7E;
        }

        /// <summary>
        /// 检测是否为可打印字符
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static bool IsPrintableAscii(this byte c)
        {
            return c >= 0x20 && c <= 0x7E;
        }

        /// <summary>
        /// 是否为16进制字符
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static bool IsHexAscii(this char c)
        {
            return c.HexCharToNum() != 255;
        }

        /// <summary>
        /// 16进制字符char转数字
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static byte HexCharToNum(this char c)
        {
            return c switch {
                '0' => 0,
                '1' => 1,
                '2' => 2,
                '3' => 3,
                '4' => 4,
                '5' => 5,
                '6' => 6,
                '7' => 7,
                '8' => 8,
                '9' => 9,
                'A' => 10,
                'B' => 11,
                'C' => 12,
                'D' => 13,
                'E' => 14,
                'F' => 15,
                'a' => 10,
                'b' => 11,
                'c' => 12,
                'd' => 13,
                'e' => 14,
                'f' => 15,
                _ => 255
            };
        }
    }
}


//CarrotLink.Core/Utility/BytesEx.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Utility
{

    // https://blog.csdn.net/qq_25482087/article/details/87925962

    public static class BytesEx
    {
        /// <summary>
        /// 检查16进制字符串格式是否符合转换要求<br/>
        /// 正确格式: 0123 ABCD abcd<br/>
        /// 分隔符支持空格<br/>
        /// 错误格式: 长度为单数/出现非0-9,a-f,A-F字符<br/>
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static bool CheckHexString(this string s)
        {
            s = s.Replace(" ", "");
            return s.All(c => c.IsHexAscii()) && s.Length % 2 == 0;
        }


        /// <summary>
        /// Convert a string of hex digits (ex: E4 CA B2) to a byte array.
        /// <code>
        /// BytesEx.HexStringToBytes("12 34 56 78 90") = new byte[] { 0x12, 0x34, 0x56, 0x78, 0x90 }
        /// </code>
        /// </summary>
        /// <param name="s"> The string containing the hex digits (with or without spaces). </param>
        /// <returns> Returns an array of bytes. </returns>
        public static byte[] HexStringToBytes(this string s)
        {
            s = s.Replace(" ", "");
            byte[] buffer = new byte[s.Length / 2];
            for (int i = 0; i < s.Length; i += 2)
            {
                buffer[i / 2] = Convert.ToByte(s.Substring(i, 2), 16);
            }

            return buffer;
        }

        /// <summary>
        /// Converts an array of bytes into a formatted string of hex digits (ex: E4 CA B2)
        /// <code>
        /// BytesEx.BytesToHexString(new byte[] { 0x12, 0x34, 0x56, 0x78, 0x90}) = "12 34 56 78 90"
        /// </code>
        /// </summary>
        /// <param name="data"> The array of bytes to be translated into a string of hex digits. </param>
        /// <returns> Returns a well formatted string of hex digits with spacing. </returns>
        public static string BytesToHexString(this byte[] data)
        {
            return BitConverter.ToString(data).Replace("-", " ");
        }

        public static string BytesToHexString(this ReadOnlySpan<byte> data)
        {
            return BitConverter.ToString(data.ToArray()).Replace("-", " ");
        }
        /// <summary>
        /// 将转换为ASCII字符串
        /// <code>
        /// BytesEx.BytesToAscii(new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34 }) = "01234"
        /// </code>
        /// </summary>
        /// <param name="arrInput">byte型数组</param>
        /// <returns>目标字符串</returns>
        public static string BytesToAscii(this byte[] arrInput)
        {
            return Encoding.ASCII.GetString(arrInput);
        }

        /// <summary>
        /// 将ASCII字符串转换为byte[]
        /// <code>
        /// BytesEx.AsciiToBytes("01234") = new byte[] { 0x30, 0x31, 0x32, 0x33, 0x34}
        /// </code>
        /// </summary>
        /// <param name="asciis"></param>
        /// <returns></returns>
        public static byte[] AsciiToBytes(this string asciis)
        {
            return Encoding.ASCII.GetBytes(asciis);
        }

        /// <summary>
        /// 将一条16进制字符串转换为ASCII
        /// </summary>
        /// <param name="hexstring">一条十六进制字符串</param>
        /// <returns>返回一条ASCII码</returns>
        public static string HexStringToASCII(this string hexstring)
        {
            byte[] bt = hexstring.HexStringToBinary();
            string lin = "";
            for (int i = 0; i < bt.Length; i++)
            {
                lin = lin + bt[i] + " ";
            }


            string[] ss = lin.Trim().Split(new char[] { ' ' });
            char[] c = new char[ss.Length];
            int a;
            for (int i = 0; i < c.Length; i++)
            {
                a = Convert.ToInt32(ss[i]);
                c[i] = Convert.ToChar(a);
            }

            string b = new string(c);
            return b;
        }

        /// <summary>
        /// 16进制字符串转换为二进制数组
        /// </summary>
        /// <param name="hexstring">用空格切割字符串</param>
        /// <returns>返回一个二进制字符串</returns>
        public static byte[] HexStringToBinary(this string hexstring)
        {

            string[] tmpary = hexstring.Trim().Split(' ');
            byte[] buff = new byte[tmpary.Length];
            for (int i = 0; i < buff.Length; i++)
            {
                buff[i] = Convert.ToByte(tmpary[i], 16);
            }
            return buff;
        }


        /// <summary>
        /// IntToBytes(0x11223344) = [ 0x44, 0x33, 0x22, 0x11 ]
        /// </summary>
        /// <param name="i">一个int数字</param>
        /// <returns>byte[]</returns>
        public static byte[] IntToBytes(this int i)
        {
            byte[] result = new byte[4];
            result[3] = (byte)(i >> 24 & 0xFF);
            result[2] = (byte)(i >> 16 & 0xFF);
            result[1] = (byte)(i >> 8 & 0xFF);
            result[0] = (byte)(i & 0xFF);
            return result;
        }

        /// <summary>
        /// byte[]转int <br/>
        /// BytesToInt(new byte[] { 0x44, 0x33, 0x22, 0x11 }) = 0x11223344
        /// </summary>
        /// <param name="bytes">byte类型数组</param>
        /// <param name="offset">数组偏移量</param>
        /// <returns>int数字</returns>
        public static int BytesToInt(this byte[] bytes, int offset)
        {
            if (bytes.Length < offset + 4)
            {
                return -1;
            }
            return (bytes[offset + 3] & 0xff) << 24
                 | (bytes[offset + 2] & 0xff) << 16
                 | (bytes[offset + 1] & 0xff) << 8
                 | (bytes[offset + 0] & 0xff) << 0;
        }

        /// <summary>
        /// IntToBytes2(0x11223344) = [ 0x11, 0x22, 0x33, 0x44 ]
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static byte[] IntToBytes2(this int value)
        {
            byte[] src = new byte[4];
            src[0] = (byte)(value >> 24 & 0xFF);
            src[1] = (byte)(value >> 16 & 0xFF);
            src[2] = (byte)(value >> 8 & 0xFF);
            src[3] = (byte)(value & 0xFF);
            return src;
        }

        /// <summary>
        /// BytesToInt2(new byte[] { 0x11, 0x22, 0x33, 0x44 }) = 0x11223344
        /// </summary>
        /// <param name="bytes">byte类型数组</param>
        /// <param name="offset">数组偏移量</param>
        /// <returns></returns>
        public static int BytesToInt2(this byte[] bytes, int offset)
        {
            if (bytes.Length < offset + 4)
            {
                return -1;
            }
            return (bytes[offset + 0] & 0xff) << 24
                 | (bytes[offset + 1] & 0xff) << 16
                 | (bytes[offset + 2] & 0xff) << 8
                 | (bytes[offset + 3] & 0xff) << 0;
        }
    }
}


//CarrotLink.Core/Utility/DriverErrorException.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Utility
{
    [Serializable]
    public class DriverErrorException : Exception
    {
        public DriverErrorException()
        {
        }

        public DriverErrorException(string message, Exception? innerException = null)
            : base($"[ERROR]::{message}", innerException)
        {

        }

        public DriverErrorException(object sender, string message, Exception? innerException = null)
            : base($"[ERROR]::{nameof(sender)}::{message}", innerException)
        {

        }
        public DriverErrorException(string sender, string message, Exception? innerException = null)
            : base($"[ERROR]::{sender}::{message}", innerException)
        {

        }
    }
}


//CarrotLink.Core/Utility/EscapeStringEx.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Utility
{
    /// <summary>
    /// 转义字符串拓展类
    /// </summary>
    public static class EscapeStringEx
    {
        /// <summary>
        /// 字节数组转转义字符串
        /// </summary>
        /// <param name="bytes">字节数组</param>
        /// <returns>转义字符串</returns>
        public static string BytesToEscapeString(this byte[] bytes)
        {
            StringBuilder stringBuilder = new();
            for (int i = 0; i < bytes.Length; i++)
            {
                // 转义字符 '\' 转义为 '\'
                if (bytes[i] == (byte)'\\')
                {
                    stringBuilder.Append(@"\\");
                }
                // 转义字符 '\r' 转义为 '\r'
                else if (bytes[i] == (byte)'\r')
                {
                    stringBuilder.Append(@"\r");
                }
                // 转义字符 '\n' 转义为 '\n'
                else if (bytes[i] == (byte)'\n')
                {
                    stringBuilder.Append(@"\n");
                }
                // 可打印字符串不转义
                else if (bytes[i].IsPrintableAscii())
                {
                    stringBuilder.Append((char)bytes[i]);
                }
                // 不可打印字符串转义为 '\NN'
                else
                {
                    stringBuilder.Append($@"\{bytes[i].ToString("X2")}");
                }
            }
            return stringBuilder.ToString();
        }

        /// <summary>
        /// 转义字符串转字节数组
        /// </summary>
        /// <param name="escapeString">转义字符串</param>
        /// <returns></returns>
        public static byte[] EscapeStringToBytes(this string escapeString)
        {
            int index = 0;
            char currentChar;
            List<byte> asciiBytes = new();
            EscapeParseStatus status = EscapeParseStatus.LoadRawChar;
            while (index < escapeString.Length)
            {
                currentChar = escapeString[index];
                switch (status)
                {
                    case EscapeParseStatus.LoadRawChar:
                        // 非转义字符
                        if (currentChar != '\\')
                        {
                            status = EscapeParseStatus.LoadRawChar;
                            asciiBytes.Add((byte)currentChar);
                            index++;
                        }
                        // 当前字符为转义开始符号'\'
                        else
                        {
                            status = EscapeParseStatus.LoadEscapeChar0;
                            index++;
                        }
                        break;
                    case EscapeParseStatus.LoadEscapeChar0:
                        // 转义字符后的第一个字符为'\\'/'\r'/'\n', 即解析为'\'/'\r'/'\n',
                        if (currentChar == '\\')
                        {
                            status = EscapeParseStatus.LoadRawChar;
                            asciiBytes.Add((byte)'\\');
                            index++;
                        }
                        else if (currentChar == 'r')
                        {
                            status = EscapeParseStatus.LoadRawChar;
                            asciiBytes.Add((byte)'\r');
                            index++;
                        }
                        else if (currentChar == 'n')
                        {
                            status = EscapeParseStatus.LoadRawChar;
                            asciiBytes.Add((byte)'\n');
                            index++;
                        }
                        // 当前字符为字节,例如'\n[\*]' '\nn'
                        else
                        {
                            byte currNum = currentChar.HexCharToNum();
                            // 字符为非16进制字符则输出'\n'
                            if (currNum == 255)
                            {
                                status = EscapeParseStatus.LoadRawChar;
                                asciiBytes.Add((byte)'\\');
                                asciiBytes.Add((byte)currentChar);
                                index++;
                            }
                            // 字符为非16进制字符则输出 'n'对应的数字
                            else
                            {
                                status = EscapeParseStatus.LoadEscapeChar1;
                                asciiBytes.Add(currNum);
                                index++;
                            }
                        }
                        break;
                    case EscapeParseStatus.LoadEscapeChar1:
                        // 转义字符后的第二个字符为'\', 即'\n\', 解析为'\n'
                        if (currentChar == '\\')
                        {
                            status = EscapeParseStatus.LoadRawChar;
                        }
                        // 当前字符为字节,例如'\n[\*]' '\nn'
                        else
                        {
                            status = EscapeParseStatus.LoadRawChar;
                            byte currNum = currentChar.HexCharToNum();
                            // 字符为非16进制字符则输出'\n'
                            if (currNum == 255)
                            {
                                asciiBytes.Add((byte)currentChar);
                                index++;
                            }
                            // 字符为非16进制字符则输出 'nn'对应的数字
                            else
                            {
                                byte addByte = (byte)((asciiBytes[^1] << 4) + currNum);
                                asciiBytes[^1] = addByte;
                                index++;
                            }
                        }
                        break;
                }
            }
            return asciiBytes.ToArray();
        }

        public enum EscapeParseStatus
        {
            /// <summary>
            /// 已读取原始字符串
            /// </summary>
            LoadRawChar,
            /// <summary>
            /// 已读取转义字符 '\'
            /// </summary>
            LoadEscapeChar0,
            /// <summary>
            /// 已读取转义字符后的第一个字符
            /// </summary>
            LoadEscapeChar1,
        }
    }
}


//CarrotLink.Core/Utility/JsonParser.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading.Tasks;

namespace CarrotLink.Core.Utility
{
    public class JsonParser
    {
        public static JsonNode? ParseToJsonNode(string json, bool ignoreDoubleQuotes = false)
        {
            return JsonNode.Parse(json);
        }

        public static JsonDocument? ParseToJsonDocument(string json, bool ignoreDoubleQuotes = false)
        {
            return JsonDocument.Parse(json);
        }
    }
}


//CarrotLink.Core/Utility/NumEx.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Utility
{
    public static class NumEx
    {
        /// <summary>
        /// 解析成数字
        /// "123" => 123
        /// "0x123" => 291
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static int ParseNum(this string s)
        {
            try
            {
                if (s.StartsWith("0x"))
                {
                    return Convert.ToInt32(s[2..], 16);
                }
                else if (s.StartsWith("0b"))
                {
                    return Convert.ToInt32(s[2..], 2);
                }
                else
                {
                    return Convert.ToInt32(s);
                }
            }
            catch
            {
                // null or error
                return 0;
            }
        }
    }
}


//CarrotLink.Core/Utility/SerializationHelper.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Text.Json.Serialization;
using System.Text.Json;
using System.Text.Encodings.Web;

namespace CarrotLink.Core.Utility
{
    /// <summary>
    /// 提供 JSON 序列化和反序列化的帮助方法。
    /// </summary>
    public class SerializationHelper
    {
        /// <summary>
        /// 全局 JSON 序列化器选项。
        /// </summary>
        private static readonly JsonSerializerOptions _globalOptions = new JsonSerializerOptions {
            Converters = { new JsonStringEnumConverter(), new BytesToHexStringConverter() },
            WriteIndented = true,
            Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
        };

        /// <summary>
        /// 将对象序列化为 JSON 字符串。
        /// </summary>
        /// <typeparam name="T">要序列化的对象的类型。</typeparam>
        /// <param name="obj">要序列化的对象。</param>
        /// <returns>对象的 JSON 字符串表示形式。</returns>
        public static string SerializeToString<T>(T obj)
        {
            return JsonSerializer.Serialize(obj, _globalOptions);
            //return "";
        }

        /// <summary>
        /// 将 JSON 字符串反序列化为对象。
        /// </summary>
        /// <typeparam name="T">要反序列化的对象的类型。</typeparam>
        /// <param name="json">要反序列化的 JSON 字符串。</param>
        /// <returns>反序列化后的对象。</returns>
        public static T? DeserializeFromString<T>(string json)
        {
            return JsonSerializer.Deserialize<T>(json, _globalOptions);
        }

        /// <summary>
        /// 将对象持久化到 JSON 文件中。
        /// </summary>
        /// <typeparam name="T">要持久化的对象的类型。</typeparam>
        /// <param name="obj">要持久化的对象。</param>
        /// <param name="filePath">要写入 JSON 文件的文件路径。</param>
        public static void SerializeToFile<T>(T obj, string filePath)
        {
            string json = SerializeToString(obj);
            File.WriteAllText(filePath, json);
        }

        /// <summary>
        /// 从 JSON 文件中加载对象。
        /// </summary>
        /// <typeparam name="T">要加载的对象的类型。</typeparam>
        /// <param name="filePath">要读取 JSON 文件的文件路径。</param>
        /// <returns>加载后的对象。</returns>
        public static T? DeserializeFromFile<T>(string filePath)
        {
            string json = File.ReadAllText(filePath);
            return DeserializeFromString<T>(json);
        }
    }

    public class BytesToHexStringConverter : JsonConverter<byte[]>
    {
        public override byte[]? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            throw new NotImplementedException();
        }

        public override void Write(Utf8JsonWriter writer, byte[] value, JsonSerializerOptions options)
        {
            writer.WriteStringValue(value.BytesToHexString());
        }
    }
}


//CarrotLink.Core/Utility/TimeoutDecorator.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotLink.Core.Utility
{
    public class TimeoutException : Exception
    {
        public TimeoutException(string message) : base(message) { }
    }

    public static class TimeoutDecorator
    {
        public static void TimeoutWrapper(Action func, int timeout)
        {
            var task = Task.Run(func);
            if (!task.Wait(timeout))
            {
                throw new TimeoutException("Timeout exceeded");
            }
        }

        public static TResult TimeoutWrapper<TResult>(Func<TResult> func, int timeout = 1000)
        {
            var task = Task.Run(func);
            if (!task.Wait(timeout))
            {
                throw new TimeoutException("Timeout exceeded");
            }
            return task.Result;
        }
    }
}


//CarrotLink.Core/Utility/TraceHelper.cs
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Sockets;
using System.Net;
using System.Text;
using System.Threading.Tasks;


namespace CarrotLink.Core.Utility
{
    public class TraceHelper
    {
        public static void Forward(Stream stream, bool autoFlush = true)
        {
            //var tcpClient = new TcpClient();
            //tcpClient.ReceiveBufferSize = 1048576;
            //IPEndPoint ipEp = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 13000);
            //tcpClient.Connect(ipEp);
            //var networkStream = tcpClient.GetStream();
            //Trace.Listeners.Add(new TextWriterTraceListener(networkStream, "127.0.0.1:13000"));
            Trace.Listeners.Add(new TextWriterTraceListener(stream, nameof(TraceHelper)));
            Trace.AutoFlush = autoFlush;
            Debug.AutoFlush = autoFlush;
        }
    }
}


//CarrotLink.Native/Class1.cs
﻿namespace CarrotLink.Native
{
    public class Class1
    {

    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/DriverFactory.cs
﻿using CarrotCommFramework.Drivers;
using CarrotCommFramework.Loggers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Sessions;
using CarrotCommFramework.Streams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace CarrotCommFramework.Factory
{
    public class DriverFactory
    {

        private static readonly DriverFactory current = new();
        public static DriverFactory Current => current;

        public Dictionary<string, IDriver> Drivers { get; private set; }

        public DriverFactory()
        {
            Register();
        }

        private void Register()
        {
            ProductProvider.Current.Register<IDriver, SerialDriver>("COM");
            ProductProvider.Current.Register<IDriver, NiVisaDriver>("VISA");
            ProductProvider.Current.Register<IDriver, FtdiDriver>("FTDI");
        }

        public static IDriver Create(string serviceKey, string instanceKey)
        {
            try
            {
                var x = ProductProvider.Current.Resolve<IDriver>(serviceKey);
                x.Name = instanceKey;
                return x;
            }
            catch (Exception _)
            {
                throw new NotImplementedException($"No Driver {serviceKey} :: {instanceKey}.");
            }
        }

        //public IDriver Create(string serviceKey, string instanceKey)
        //{
        //    serviceKey = serviceKey.ToUpper();
        //    if (serviceKey == "COM")
        //        return new SerialDriver() { Name = instanceKey };
        //    else if (serviceKey == "GPIB")
        //        return new GpibDriver() { Name = instanceKey };
        //    else
        //        throw new NotImplementedException($"No Driver {serviceKey}.");
        //}

        public IDriver Get(string serviceKey, string instanceKey)
        {
            if (Drivers.TryGetValue(instanceKey, out var instance))
                return instance;
            else
            {
                var service = Create(serviceKey!, instanceKey);
                Drivers.Add(instanceKey, service);
                return service;
            }
        }

        /// <summary>
        /// 获取设备名称
        /// </summary>
        /// <param name="filter"></param>
        /// <returns></returns>
        public DeviceInfo[] FindDevices(string filter = null)
        {
            Drivers = [];
            foreach (var i in ProductProvider.Current.Resolve<IDriver[]>(null))
                Drivers.Add(i.Name, i);

            List<DeviceInfo> devicesFound = [];
            var drivers = Drivers;
            foreach (var driver in drivers)
            {
                var devs = driver.Value.FindDevices();
                devicesFound.AddRange(devs);
            }
            return devicesFound.ToArray();
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/LoggerFactory.cs
﻿using CarrotCommFramework.Drivers;
using CarrotCommFramework.Loggers;
using CarrotCommFramework.Sessions;
using CarrotCommFramework.Streams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Factory
{
    public class LoggerFactory
    {
        private static readonly LoggerFactory current = new();
        public static LoggerFactory Current => current;

        /// <summary>
        /// Loggers存储 Key:InstanceKey Value:ILogger 接口派生类
        /// </summary>
        public Dictionary<string, ILogger> Loggers { get; private set; } = new();

        public LoggerFactory()
        {
            Register();
        }

        private static void Register()
        {
            ProductProvider.Current.Register<ILogger, ConsoleLogger>("CONSOLE");
            ProductProvider.Current.Register<ILogger, NLogLogger>("NLOG");
        }

        public static ILogger Create(string serviceKey, string instanceKey)
        {
            try
            {
                var x = ProductProvider.Current.Resolve<ILogger>(serviceKey);
                x.Name = instanceKey;
                return x;
            }
            catch (Exception _)
            {
                throw new NotImplementedException($"No Logger {serviceKey} :: {instanceKey}.");
            }
        }

        //private ILogger Create(string serviceKey, string instanceKey)
        //{
        //    serviceKey = serviceKey.ToUpper();
        //    if (serviceKey == "CONSOLE")
        //        return new ConsoleLogger() { Name = instanceKey };
        //    else if (serviceKey == "NLOG")
        //        return new NLogLogger() { Name = instanceKey };
        //    else
        //        throw new NotImplementedException($"No Logger {serviceKey}.");
        //}

        public ILogger Get(string serviceKey, string instanceKey, IDictionary<string, string> @params = default!)
        {
            if (Loggers.TryGetValue(instanceKey, out var instance))
                return instance;
            else
            {
                var service = Create(serviceKey!, instanceKey);
                service.Config(@params);
                Loggers.Add(instanceKey, service);
                return service;
            }
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/ProductManager.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Factory
{
    public class ProductManager
    {
        private static readonly ProductManager current = new();
        public static ProductManager Current => current;

    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/ProductProvider.cs
﻿using CarrotCommFramework.Protocols;
using DryIoc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Factory
{
    public class ProductProvider
    {
        private static readonly ProductProvider current = new();
        public static ProductProvider Current => current;

        public Container Container { get; set; } = new Container();

        public ProductProvider()
        {
        }

        public void Register<TService, TImplementation>(string serviceKey)
        {
            Container.Register(typeof(TService), typeof(TImplementation), serviceKey: serviceKey);
        }

        public TService Resolve<TService>(string? serviceKey)
        {
            if (serviceKey == null)
                return Container.Resolve<TService>();
            else
                return Container.Resolve<TService>(serviceKey);
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/ProtocolFactory.cs
﻿using CarrotCommFramework.Drivers;
using CarrotCommFramework.Loggers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Sessions;
using CarrotCommFramework.Streams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Factory
{
    public class ProtocolFactory
    {
        private static readonly ProtocolFactory current = new();
        public static ProtocolFactory Current => current;

        /// <summary>
        /// Protocols存储 Key:InstanceKey Value:IProtocol 接口派生类
        /// </summary>
        public Dictionary<string, IProtocol> Protocols { get; private set; } = new();

        public ProtocolFactory()
        {
            Register();
        }

        private static void Register()
        {
            ProductProvider.Current.Register<IProtocol, RawAsciiProtocol>("RAPV1");
            //ProductProvider.Current.Register<IProtocol, CarrotDataProtocol>("CDPV1");
        }

        public static IProtocol Create(string serviceKey, string instanceKey)
        {
            try
            {
                var x = ProductProvider.Current.Resolve<IProtocol>(serviceKey);
                x.Name = instanceKey;
                return x;
            }
            catch (Exception _)
            {
                throw new NotImplementedException($"No Protocol {serviceKey} :: {instanceKey}.");
            }
        }

        //public IProtocol Create(string serviceKey, string instanceKey)
        //{
        //    serviceKey = serviceKey.ToUpper();
        //    if (serviceKey == "RAPV1")
        //        return new RawAsciiProtocol() { Name = instanceKey };
        //    else if (serviceKey == "CDPV1")
        //        return new CarrotDataProtocol() { Name = instanceKey };
        //    else
        //        throw new NotImplementedException($"No Protocol {serviceKey}.");
        //}

        public IProtocol Get(string serviceKey, string instanceKey, IDictionary<string, string> @params = default!)
        {
            if (Protocols.TryGetValue(instanceKey, out var instance))
                return instance;
            else
            {
                var service = Create(serviceKey!, instanceKey);
                //service.Config(@params);
                Protocols.Add(instanceKey, service);
                return service;
            }
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/ServiceFactory.cs
﻿using CarrotCommFramework.Loggers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Services;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Factory
{
    public class ServiceFactory
    {
        private static readonly ServiceFactory current = new();
        public static ServiceFactory Current => current;

        /// <summary>
        /// Services 存储 Key:InstanceKey Value:IProtocol 接口派生类
        /// </summary>
        public Dictionary<string, ISessionServiceBase> Services { get; private set; } = new();

        public ServiceFactory()
        {
            Register();
        }

        private static void Register()
        {
            ProductProvider.Current.Register<ISessionServiceBase, DataRecvService>("RECV");
            ProductProvider.Current.Register<ISessionServiceBase, ProtocolParseService>("PARSE");
        }

        public static ISessionServiceBase Create(string serviceKey, string instanceKey)
        {
            try
            {
                var x = ProductProvider.Current.Resolve<ISessionServiceBase>(serviceKey);
                x.Name = instanceKey;
                return x;
            }
            catch (Exception _)
            {
                throw new NotImplementedException($"No Service {serviceKey} :: {instanceKey}.");
            }
        }

        //public ISessionServiceBase Create(string serviceKey, string instanceKey)
        //{
        //    serviceKey = serviceKey.ToUpper();
        //    if (serviceKey == "RECV")
        //        return new DataRecvService() { Name = instanceKey };
        //    else if (serviceKey == "PARSE")
        //        return new ProtocolParseService() { Name = instanceKey };
        //    else
        //        throw new NotImplementedException($"No Service {serviceKey}.");
        //}

        public ISessionServiceBase Get(string serviceKey, string instanceKey, IDictionary<string, string> @params = default!)
        {
            if (Services.TryGetValue(instanceKey, out var instance))
                return instance;
            else
            {
                var service = Create(serviceKey!, instanceKey);
                //service.Config(@params);
                Services.Add(instanceKey, service);
                return service;
            }
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/SessionFactory.cs
﻿using CarrotCommFramework.Sessions;
using System.Diagnostics;

namespace CarrotCommFramework.Factory
{

    public class SessionFactory
    {
        private static readonly SessionFactory current = new();
        public static SessionFactory Current => current;

        public Dictionary<string, Session> Sessions { get; private set; } = new();

        public SessionFactory()
        {
        }

        public Session CreateSession(string addrs, IOptions options)
        {

            // create
            var opts = options.Flatten();
            foreach (var opt in opts)
            {
                string interf = opt.Sources.TryGetValue("interface", out string? val1) ? val1 : "null";
                string type = opt.Sources.TryGetValue("type", out string? val2) ? val2 : "default";
                string name = opt.Sources.TryGetValue("name", out string? val3) ? val3 : "unnamed";
                switch (interf)
                {
                    case "session":
                        Session s = new();
                        Sessions.Add(name, s);
                        Console.WriteLine($"Create Session: {name}");
                        break;
                    case "stream":
                        var stream = StreamFactory.Current.Get(type, name, opt.Sources);
                        Console.WriteLine($"Create Stream: {type}:{name}");
                        //s.Streams.Add(stream);
                        break;
                    case "logger":
                        var logger = LoggerFactory.Current.Get(type, name, opt.Sources);
                        Console.WriteLine($"Create Logger: {type}:{name}");
                        //s.Loggers.Add(logger);
                        break;
                    case "protocol":
                        var protocol = ProtocolFactory.Current.Get(type, name, opt.Sources);
                        Console.WriteLine($"Create Protocol: {type}:{name}");
                        //s.Protocols.Add(protocol);
                        break;
                    case "service":
                        var service = ServiceFactory.Current.Get(type, name, opt.Sources);
                        Console.WriteLine($"Create Service: {type}:{name}");
                        //s.Services.Add(service);
                        break;
                    default:
                        break;
                }
            }

            // bind
            foreach (var opt in opts)
            {
                if (opt.NestedSources.Count != 0
                    && opt.Sources.TryGetValue("interface", out string? val3)
                    && val3 == "session")
                {
                    string name1 = opt.Sources.TryGetValue("name", out string? val1) ? val1 : "unnamed";
                    Current.TryGet(name1, out Session? s);
                    foreach (var src in opt.NestedSources)
                    {
                        string interf = src.Sources.TryGetValue("interface", out string? val4) ? val4 : "null";
                        string name = src.Sources.TryGetValue("name", out string? val5) ? val5 : "unnamed";

                        switch (interf)
                        {
                            case "stream":
                                var stream = StreamFactory.Current.Get(null, name, null);
                                s.Streams.Add(stream);
                                break;
                            case "logger":
                                var logger = LoggerFactory.Current.Get(null, name, null);
                                s.Loggers.Add(logger);
                                break;
                            case "protocol":
                                var protocol = ProtocolFactory.Current.Get(null, name, null);
                                s.Protocols.Add(protocol);
                                break;
                            case "service":
                                var service = ServiceFactory.Current.Get(null, name, null);
                                s.Services.Add(service);
                                break;
                            default:
                                break;
                        }
                    }
                    s.Bind();
                    return s;
                }
            }

            return null;
        }

        public bool TryGet(string id, out Session? session)
        {
            return Sessions.TryGetValue(id, out session);
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Factory/StreamFactory.cs
﻿using CarrotCommFramework.Drivers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Services;
using CarrotCommFramework.Sessions;
using CarrotCommFramework.Streams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Factory
{
    public class StreamFactory
    {
        private static readonly StreamFactory current = new();
        public static StreamFactory Current => current;

        public Dictionary<string, IAsyncStream> Streams { get; private set; } = new();

        public StreamFactory()
        {
            Register();
        }

        private static void Register()
        {
            ProductProvider.Current.Register<IAsyncStream, SerialStream>("COM");
            ProductProvider.Current.Register<IAsyncStream, FtdiStream>("FTDI");
            ProductProvider.Current.Register<IAsyncStream, NiVisaStream>("VISA");
        }

        public static IAsyncStream Create(string serviceKey, string instanceKey)
        {
            try
            {
                var x = ProductProvider.Current.Resolve<IAsyncStream>(serviceKey);
                x.Name = instanceKey;
                return x;
            }
            catch (Exception _)
            {
                throw new NotImplementedException($"No Stream {serviceKey} :: {instanceKey}.");
            }
        }
        //public static IAsyncStream Create(string serviceKey, string instanceKey)
        //{
        //    serviceKey = serviceKey.ToUpper();
        //    if (serviceKey == "COM")
        //        return new SerialStream() { };
        //    //else if (serviceKey == "GPIB")
        //    //    return new VisaGpibStream(instanceKey);
        //    else
        //        throw new NotImplementedException($"No Stream {serviceKey}.");
        //}

        public IAsyncStream Get(string serviceKey, string instanceKey, IDictionary<string, string> @params = default!)
        {
            if (Streams.TryGetValue(instanceKey, out var instance))
                return instance;
            else
            {
                var service = Create(serviceKey!, instanceKey);
                service.Config(@params);
                Streams.Add(instanceKey, service);
                return service;
            }
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Services/DataRecvService.cs
﻿using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Reflection.PortableExecutable;
using System.Text;
using System.Threading.Tasks;
using System.IO.Pipelines;
using CarrotCommFramework.Streams;
using CarrotCommFramework.Protocols;
using System.IO;
using System.Diagnostics;

namespace CarrotCommFramework.Services
{
    public class DataRecvService : SessionServiceBase
    {
        public Task Task { get; set; }

        public DataRecvService()
        {
        }

        // Read From IDriverCommStream and write to pipewriter
        public override async Task Impl()
        {
            PipeWriter writer = Stream!.Pipe.Writer;

            const int BUFSIZE = 1048576;
            // TODO:临时缓冲区
            byte[] rxTemp = new byte[BUFSIZE];

            while (true)
            {
                if (Cts.Token.IsCancellationRequested)
                {
                    break;
                }

                // PipeWriter获取BUFSIZE大小的内存
                Memory<byte> buffer = writer.GetMemory(BUFSIZE);
                try
                {
                    // 读取数据
                    // TODO 重构ReadAsync
                    //int bytesRead = await Stream!.ReadAsync(buffer, 0, BUFSIZE, Cts.Token);
                    // TODO 性能优化测试
                    int bytesRead = await Stream!.ReadAsync(rxTemp, 0, BUFSIZE, Cts.Token).ConfigureAwait(false);
                    //int bytesRead = await Stream!.ReadAsync(rxTemp, 0, BUFSIZE, Cts.Token);
                    if (bytesRead == 0)
                    {
                        break;
                    }

                    // TODO
                    rxTemp.CopyTo(buffer);
                    // 通知PipeWriter多少数据已写入缓冲区
                    writer.Advance(bytesRead);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine(ex.ToString());
                    throw;
                }

                // Flush数据到PipeReader
                // TODO 性能优化测试
                FlushResult result = await writer.FlushAsync(Cts.Token).ConfigureAwait(false);
                //FlushResult result = await writer.FlushAsync(Cts.Token);

                // 来自PipeReader的EOF处理
                if (result.IsCompleted)
                {
                    await writer.CompleteAsync();
                    Debug.WriteLine($"{nameof(DataRecvService)} returning");
                    break;
                }
            }

            // PipeWriter EOF数据传输结束指示
            await writer.CompleteAsync();
            Debug.WriteLine($"{nameof(DataRecvService)} returning");

            Status = ServiceStatus.ExitSuccess;
        }
    }
}

//CarrotLink.Old/CarrotCommFramework/Services/ProtocolParseService.cs
﻿using CarrotCommFramework.Loggers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Streams;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Services
{
    public class ProtocolParseService : SessionServiceBase
    {
        public Task Task { get; set; }

        public string Name { get; set; }

        public ProtocolParseService()
        {
        }

        // PipeReader Read From PipeWriter and Process data
        public override async Task Impl()
        {
            try
            {
                PipeReader reader = Stream!.Pipe.Reader;

                while (true)
                {
                    if (Cts.Token.IsCancellationRequested)
                    {
                        break;
                    }

                    // 读取数据, 返回buffer和是否EOF
                    ReadResult result = await reader.ReadAsync(Cts.Token);

                    ReadOnlySequence<byte> buffer = result.Buffer;

                    if (RawAsciiProtocol.TryParse(ref buffer, out var pkt))
                    {
                        // 处理数据流
                        //Debug.WriteLine($"RECV PACKET: {packet.Message}");
                        OnServiceLogging(this,
                            new LogEventArgs()
                            {
                                Time = DateTime.Now,
                                From = "RX",
                                Packet = pkt
                            });
                        reader.AdvanceTo(buffer.Start);
                    }
                    else
                    {
                        // Tell the PipeReader how much of the buffer has been consumed.
                        reader.AdvanceTo(buffer.Start, buffer.End);
                    }

                    // 来自PipeWriter EOF数据传输结束
                    if (result.IsCompleted)
                    {
                        await reader.CompleteAsync();
                        Debug.WriteLine($"{nameof(ProtocolParseService)} returning");
                        break;
                    }
                }

                // PipeReader EOF数据传输结束指示
                await reader.CompleteAsync();
                Debug.WriteLine($"{nameof(ProtocolParseService)} returning");

                Status = ServiceStatus.ExitSuccess;
            }
            catch (Exception e)
            {
                Debug.WriteLine(e.ToString());
                throw;
            }
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Services/ServiceBase.cs
﻿using CarrotCommFramework.Loggers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Streams;
using System;
using System.Collections.Generic;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Services
{
    /// <summary>
    /// 服务状态
    /// </summary>
    public enum ServiceStatus
    {
        WaitForStart,
        Running,
        Cancelling,
        ExitSuccess,
        Cancelled,
        ThrowException
    }

    /// <summary>
    /// 服务接口
    /// </summary>
    public interface IServiceBase<TReturn>
    {
        /// <summary>
        /// 服务返回值
        /// </summary>
        public TReturn? ReturnValue { get; }

        /// <summary>
        /// 服务状态
        /// </summary>
        public ServiceStatus Status { get; }

        /// <summary>
        /// 服务异常
        /// </summary>
        public Exception? InternalException { get; }

        /// <summary>
        /// 打开服务
        /// </summary>
        void Start();

        /// <summary>
        /// 停止服务
        /// </summary>
        void Stop();
    }

    /// <summary>
    /// 服务基类
    /// </summary>
    /// <typeparam name="TReturn"></typeparam>
    public abstract class ServiceBase<TReturn> : IServiceBase<TReturn>
    {
        /// <summary>
        /// 取消信号
        /// </summary>
        public CancellationTokenSource Cts { get; set; }

        /// <summary>
        /// 服务实例
        /// </summary>
        private Task<TReturn?>? Service { get; set; }

        /// <summary>
        /// 服务返回值
        /// </summary>
        public TReturn? ReturnValue { get; set; }

        /// <summary>
        /// 服务状态
        /// </summary>
        public ServiceStatus Status { get; set; }

        /// <summary>
        /// 服务异常
        /// </summary>
        public Exception? InternalException { get; set; }

        /// <summary>
        /// 是否外部请求取消任务
        /// </summary>
        public bool IsCancellationRequested
        {
            get
            {
                if (Cts.Token.IsCancellationRequested)
                    Status = ServiceStatus.Cancelling;
                return Cts.Token.IsCancellationRequested;
            }
        }


        /// <summary>
        /// 构造函数
        /// </summary>
        public ServiceBase()
        {
            Cts = new();
            ReturnValue = default;
            Status = ServiceStatus.WaitForStart;
            InternalException = null;
        }

        /// <summary>
        /// 打开服务
        /// </summary>
        public void Start()
        {
            Cts = new();
            Service = Impl(Cts.Token);
            Status = ServiceStatus.Running;
        }

        /// <summary>
        /// 停止服务
        /// </summary>
        public void Stop()
        {
            Cts.Cancel();
            try
            {
                Service?.Wait();
            }
            catch (Exception)
            {

            }
        }

        /// <summary>
        /// 服务实现方法
        /// </summary>
        /// <param name="ct">返回</param>
        /// <returns>返回值</returns>
        public virtual async Task<TReturn?> Impl(CancellationToken ct)
        {
            return await Task.FromResult<TReturn>(default(TReturn?));
        }

        //public async Task<TReturn?> Impl(CancellationToken ct)
        //{
        //    for (int i = 0; i < 5; i++)
        //    {
        //        Debug.WriteLine("Hello");
        //        await Task.Delay(500, ct);
        //    }
        //    return await Task.FromResult(default(TReturn?));
        //}

        //public async Task<TReturn?> ImplTask(CancellationToken ct)
        //{
        //    return await Task<TReturn?>.Run(() => Impl(ct), ct);
        //}
    }
}


//CarrotLink.Old/CarrotCommFramework/Services/SessionServiceBase.cs
﻿using CarrotCommFramework.Loggers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Streams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Services
{
    /// <summary>
    /// 记录器事件委托
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    public delegate void LogEventHandler(object sender, LogEventArgs e);

    /// <summary>
    /// 通信协议会话服务接口
    /// </summary>
    public interface ISessionServiceBase : IServiceBase<object>
    {
        public string Name { get; set; }

        /// <summary>
        /// 记录器事件
        /// </summary>
        public event LogEventHandler? Logging;

        /// <summary>
        /// 配置绑定
        /// </summary>
        /// <param name="stream"></param>
        /// <param name="protocol"></param>
        public void Bind(IAsyncStream? stream, IProtocol? protocol = null);
    }

    /// <summary>
    /// 通信协议会话服务基类
    /// </summary>
    public abstract class SessionServiceBase : ServiceBase<object>, ISessionServiceBase
    {
        public string Name { get; set; }

        /// <summary>
        /// 数据流接口
        /// </summary>
        public IAsyncStream? Stream { get; set; }

        /// <summary>
        /// 数据协议接口
        /// </summary>
        public IProtocol? Protocol { get; set; }


        /// <summary>
        /// 记录器事件
        /// </summary>
        public event LogEventHandler? Logging;

        /// <summary>
        /// 配置绑定
        /// </summary>
        /// <param name="stream"></param>
        /// <param name="protocol"></param>
        public virtual void Bind(IAsyncStream? stream, IProtocol? protocol = null)
        {
            Stream = stream;
            Protocol = protocol;
            Console.WriteLine($"Service {Name} binding {stream.Name}, {protocol.Name}");
        }

        /// <summary>
        /// 服务实现方法
        /// </summary>
        /// <param name="ct">返回</param>
        /// <returns>返回值</returns>
        public override async Task<object?> Impl(CancellationToken ct)
        {
            try
            {
                await Impl();
                return await Task.FromResult<object?>(null);
            }
            catch (Exception ex)
            {
                InternalException = ex;
                throw;
            }
        }


        /// <summary>
        /// 无返回值服务实现方法
        /// </summary>
        /// <returns></returns>
        public virtual async Task Impl()
        {
            await Task.Delay(1);
        }

        /// <summary>
        /// 引发基类事件，用于派生类重载
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected virtual void OnServiceLogging(object sender, LogEventArgs e)
        {
            Logging?.Invoke(sender, e);
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Sessions/Options.cs
﻿using DryIoc.ImTools;
using NationalInstruments.Restricted;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace CarrotCommFramework.Sessions
{
    public interface IOptions
    {
        public Dictionary<string, string> Sources { get; set; }
        public List<IOptions> NestedSources { get; set; }

        public IEnumerable<IOptions> Flatten();
    }

    public class Options : IOptions
    {
        public Dictionary<string, string> Sources { get; set; }
        public List<IOptions> NestedSources { get; set; }

        public Options()
        {
            Sources = new();
            NestedSources = new();
        }

        public override string ToString()
        {
            return JsonSerializer.Serialize(this, new JsonSerializerOptions()
            {
                WriteIndented = true,
            });
        }

        public IEnumerable<IOptions> Flatten()
        {
            List<IOptions> flat = new List<IOptions>();
            flat.Add(this);
            foreach (IOptions src in NestedSources)
            {
                flat.AddRange(src.Flatten());
            }
            return flat;
        }
    }

}


//CarrotLink.Old/CarrotCommFramework/Sessions/OptionsBuilder.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace CarrotCommFramework.Sessions
{
    public interface IOptionBuilder<TOption>
    {
        public Dictionary<string, string> Sources { get; set; }
        public List<IOptionBuilder<IOptions>> Builders { get; set; }

        public TOption Build();
    }

    public class OptionsBuilder : IOptionBuilder<IOptions>
    {
        public Dictionary<string, string> Sources { get; set; } = new();
        public List<IOptionBuilder<IOptions>> Builders { get; set; } = new();

        public OptionsBuilder()
        {
        }

        public IOptions Build()
        {
            var opt = new Options();
            foreach (var src in Sources)
            {
                opt.Sources.Add(src.Key, src.Value);
            }
            foreach (var builder in Builders)
            {
                opt.NestedSources.Add(builder.Build());
            }
            return opt;
        }
    }

    public static class MyOptionBuilderExtensions
    {
        public static IOptionBuilder<IOptions> Add(this IOptionBuilder<IOptions> builder, string key, string val)
        {
            builder.Sources.Add(key, val);
            return builder;
        }

        public static IOptionBuilder<IOptions> Add(this IOptionBuilder<IOptions> builder, Action<IOptionBuilder<IOptions>> action)
        {
            var inst = new OptionsBuilder();
            action(inst);
            builder.Builders.Add(inst);
            return builder;
        }

        /*
        public static IOptionBuilder<IOptions> Add<TBuilder>(this IOptionBuilder<IOptions> builder, Action<TBuilder> action) where TBuilder : IOptionBuilder<IOptions>, new()
        {
            var inst = new TBuilder();
            action(inst);
            builder.Builders.Add(inst);
            return builder;
        }
        */

        public static IOptionBuilder<IOptions> Interface(this IOptionBuilder<IOptions> builder, string @interface)
        {
            builder.Sources["interface"] = @interface;
            return builder;
        }

        public static IOptionBuilder<IOptions> Type(this IOptionBuilder<IOptions> builder, string type)
        {
            builder.Sources["type"] = type;
            return builder;
        }

        public static IOptionBuilder<IOptions> Name(this IOptionBuilder<IOptions> builder, string name)
        {
            builder.Sources["name"] = name;
            return builder;
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Sessions/Session.cs
﻿using CarrotCommFramework.Loggers;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Services;
using CarrotCommFramework.Streams;
using CarrotCommFramework.Util;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Sessions
{
    public class Session
    {
        public string Name { get; set; }
        public List<IAsyncStream> Streams { get; set; }
        public List<ILogger> Loggers { get; set; }
        public List<IProtocol> Protocols { get; set; }
        public List<ISessionServiceBase> Services { get; set; }


        public Session()
        {
            Streams = [];
            Loggers = [];
            Protocols = [];
            Services = [];
        }

        public void Bind()
        {
            foreach (var (stream, protocol) in Streams.Zip(Protocols))
            {
                foreach (var service in Services)
                {
                    service.Bind(stream, protocol);

                    foreach (var logger in Loggers)
                    {
                        service.Logging += logger.Log;
                    }
                }
            }
        }

        public void Open()
        {
            Streams![0].Open();
            foreach (var service in Services)
            {
                service.Start();
            }
        }

        public void Close()
        {
            foreach (var service in Services)
            {
                service.Stop();
            }

            Streams![0].Close();

            // Wait
            foreach (var service in Services)
            {
                while (true)
                {
                    if (service.Status == ServiceStatus.ExitSuccess)
                    {
                        Console.WriteLine($"{service} IS STOPPED, Status = {service.Status}.");
                        break;
                    }
                    else if (service.Status == ServiceStatus.Cancelled)
                    {
                        Console.WriteLine($"{service} IS STOPPED, Status = {service.Status}.");
                        break;
                    }
                    else if (service.Status == ServiceStatus.ThrowException)
                    {
                        Console.WriteLine($"{service} IS STOPPED, Status = {service.Status}.");
                        break;
                    }
                    else
                    {
                        Console.WriteLine($"{service} IS STOPPING, Status = {service.Status}.");
                        Thread.Sleep(250);
                    }
                }
            }
        }

        public void Write(Packet s)
        {
            var tx = s.Bytes;
            Streams[0].Write(tx, 0, tx.Length);

            foreach (var logger in Loggers)
            {
                logger.Log(this, new LogEventArgs()
                {
                    Time = DateTime.Now,
                    From = "TX",
                    Packet = s
                });
            }
        }

        public void Write(byte[] buffer, int offset, int count)
        {
            Streams[0].Write(buffer, offset, count);
        }

        public int Read(byte[] buffer, int offset, int count)
        {
            return Streams[0].Read(buffer, offset, count);
        }
        /*
        public void Read(out IEnumerable<Packet>? packets)
        {
            byte[] bytes = new byte[1048576];
            int len = Streams[0].Read(bytes, 0, bytes.Length);
            ReadOnlySequence<byte> mem = new ReadOnlySequence<byte>(bytes);
            // TODO
            Protocols[0].TryParse(ref mem, out packets,out _);
        }
        */
        public bool TryReadLast(string filter, out Packet? packet)
        {
            int loggerNo = Convert.ToInt16(filter);
            if (Loggers.Count > loggerNo)
            {
                return Loggers[loggerNo].TryGet(-1, out packet);
            }
            else
            {
                packet = null;
                return false;
            }
        }
    }
}


//CarrotLink.Old/CarrotCommFramework/Sessions/SessionConfigNameGenerater.cs
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Sessions
{
    public class SessionConfigNameGenerater
    {
        public static class SessionConfigInstanceCounter
        {
            public static readonly Dictionary<string, int> AutoGenerateInstanceCount = new();
        }

        /*
        public void GenerateInstanceName(SessionComponentInfo info)
        {
            if (string.IsNullOrEmpty(info.InstanceName))
            {
                int newVal = 0;
                if (SessionConfigInstanceCounter.AutoGenerateInstanceCount.TryGetValue((info.Type, info.ServiceName), out int val))
                {
                    SessionConfigInstanceCounter.AutoGenerateInstanceCount[(info.Type, info.ServiceName)] = (val + 1);
                    newVal = (val + 1);
                }
                else
                {
                    SessionConfigInstanceCounter.AutoGenerateInstanceCount.Add((info.Type, info.ServiceName), 0);
                }
                info.InstanceName = $"{info.ServiceName}_inst{newVal}";
                Console.WriteLine($"({info.Type}, {info.ServiceName}):{newVal}");
            }
        }
        */
    }
}


//CarrotLink.Old/CarrotCommFramework/Streams/BufferedStream.cs
﻿using CarrotCommFramework.Streams;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO.Pipelines;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFramework.Streams
{
    /// <summary>
    /// FIFO环形缓冲区
    /// </summary>
    public class BufferedStream : StreamBase
    {
        public Pipe Pipe { get; set; } = new();

        public IStream BaseStream { get; private set; }
        public RingBuffer Rb { get; set; }
        public string Address { get; set; }
        public string LoggerKey { get; set; }

        public bool ReadAvailable => Rb.Count > 0;

        private int BufferSize { get; set; }

        private byte[] RxArray { get; set; }

        private int RxArrayLength { get; set; }

        private readonly CancellationTokenSource cts = new();

        public BufferedStream(IStream stream, int bufferSize = 16 * 1048576)
        {
            BaseStream = stream;
            BufferSize = bufferSize;
            Rb = new RingBuffer(bufferSize);
            RxArrayLength = 1048576;
            RxArray = new byte[RxArrayLength];
        }

        public override void Open()
        {
            BaseStream.Open();
            Task.Run(RecvService, cts.Token);
        }

        public override void Close()
        {
            cts.Cancel();
        }

        public void RecvService()
        {
            try
            {
                while (!cts.IsCancellationRequested)
                {
                    if (BaseStream.ReadAvailable)
                    {
                        int bytesRead = BaseStream.Read(RxArray, 0, RxArrayLength);
                        Rb.Write(RxArray, 0, bytesRead);
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }

        public override int Read(byte[] buffer, int offset, int count)
        {
            Rb.Read(buffer, offset, count);
            return count;
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            BaseStream.Write(buffer, offset, count);
        }

        public override void Config(IDictionary<string, string> @params = null)
        {

        }
    }

    /// <summary>
    /// FIFO环形缓冲区
    /// </summary>
    public class RingBuffer
    {
        /// <summary>
        /// 缓冲区
        /// </summary>
        public byte[] Buffer { get; set; }

        /// <summary>
        /// 数据字节数
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        /// 数据头指针索引
        /// </summary>
        public int HeadIndex { get; set; }

        /// <summary>
        /// 数据尾指针索引
        /// </summary>
        public int TailIndex { get; set; }

        /// <summary>
        /// 线程安全管理
        /// </summary>
        private object LockObject;

        /// <summary>
        /// 缓冲区初始化
        /// </summary>
        /// <param name="bufferSize"></param>
        public RingBuffer(int bufferSize)
        {
            Count = 0;
            HeadIndex = 0;
            TailIndex = 0;
            Buffer = new byte[bufferSize];
            LockObject = new object();
        }

        /// <summary>
        /// 获取环形缓冲区下标位置字节
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        /// <exception cref="IndexOutOfRangeException"></exception>
        public byte this[int index]
        {
            get
            {
                if (index >= Count)
                    throw new IndexOutOfRangeException("环形缓冲区索引溢出");
                lock (LockObject)
                {
                    return Buffer[(HeadIndex + index) % Buffer.Length];
                }
            }
        }

        /// <summary>
        /// 清空缓冲区
        /// </summary>
        public void Clear()
        {
            lock (LockObject)
            {
                Count = 0;
                HeadIndex = 0;
                TailIndex = 0;
            }
        }

        /// <summary>
        /// 写缓冲区
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        public void Write(byte[] buffer, int offset, int count)
        {
            // 缓冲区满
            if (Count + count > Buffer.Length)
            {
                throw new IndexOutOfRangeException("环形缓冲区过小");
            }

            int bytesToWrite = count;
            int bytesCount = HeadIndex + count < Buffer.Length ? count : Buffer.Length - HeadIndex;

            lock (LockObject)
            {
                // 缓冲区写入
                Array.Copy(buffer, offset, Buffer, HeadIndex, bytesCount);
                HeadIndex += bytesCount;
                Count += bytesCount;
                bytesToWrite -= bytesCount;

                // 跨缓冲区边界写入
                if (bytesToWrite != 0)
                {
                    HeadIndex = 0;
                    Array.Copy(buffer, offset + bytesCount, Buffer, HeadIndex, bytesToWrite);
                    HeadIndex += count;
                    Count += bytesToWrite;
                }
            }
        }

        public void Write(byte[] buffer)
        {
            Write(buffer, 0, buffer.Length);
        }

        public void Read(byte[] buffer, int offset, int count)
        {
            // 读取长度大于数据长度
            if (count > Count)
            {
                throw new IndexOutOfRangeException("环形缓冲区读取长度大于数据长度");
            }

            int bytesToRead = count;
            int bytesCount = TailIndex + count < Buffer.Length ? count : Buffer.Length - TailIndex;

            lock (LockObject)
            {
                // 缓冲区读取
                Array.Copy(Buffer, TailIndex, buffer, offset, bytesCount);
                TailIndex += bytesCount;
                Count -= bytesCount;
                bytesToRead -= bytesCount;

                // 跨缓冲区边界读取
                if (bytesToRead != 0)
                {
                    TailIndex = 0;
                    Array.Copy(Buffer, TailIndex, buffer, offset + bytesCount, bytesToRead);
                    TailIndex += count;
                    Count -= bytesToRead;
                }
            }
        }

        public void Read(byte[] buffer)
        {
            Read(buffer, 0, buffer.Length);
        }
    }
}


//CarrotLink.Old/CarrotCommFrameworkDemo/BatchWriter.cs
﻿using CarrotCommFramework.Protocols;
using CarrotCommFramework.Sessions;
using CarrotCommFramework.Util;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CarrotCommFrameworkDemo
{
    public static class BatchWriter
    {
        public static void Run(Session s, string[] cmds, int delay = 100)
        {
            for (int i = 0; i < cmds.Length; i++)
            {
                Console.WriteLine(cmds[i]);
                s.Write(new((cmds[i] + "\r\n").AsciiToBytes()));
                if (cmds[i].Contains('?'))
                {
                    Console.WriteLine("WAITING");
                    byte[] rx = new byte[1024];
                    int len = s.Read(rx, 0, 1024);
                    Console.WriteLine($"{rx.Take(len).ToArray().BytesToAscii()}");
                }
                else
                {
                    Thread.Sleep(delay);
                }
            }
        }
        public static void RunFromFile(Session s, string filename, int delay = 100)
        {
            var cmds = File.ReadAllLines(filename);
            Run(s, cmds, delay);
        }
    }
}


//CarrotLink.Old/CarrotCommFrameworkDemo/Program.cs
﻿using CarrotCommFramework.Sessions;
using System.Net.Sockets;
using System.Net;
using CarrotCommFramework.Factory;
using CarrotCommFramework.Services;
using CarrotCommFramework.Loggers;
using DryIoc;
using CarrotCommFramework.Protocols;
using CarrotCommFramework.Streams;
using System.Diagnostics;
using CarrotCommFramework.Util;
using System.Text.Json.Serialization;

namespace CarrotCommFrameworkDemo
{
    public class Program
    {
        static void Main(string[] args)
        {

            // logger注册以及ioc模块日志创建object记录
            ProductProvider.Current.Container.RegisterInitializer<object>(
                (anyObj, resolver) => Console.WriteLine($"Object {{{anyObj}}} Resolved."));

            // 查找现有设备
            var deviceInfos = DriverFactory.Current.FindDevices();
            foreach (var deviceInfo in deviceInfos)
            {
                Console.WriteLine($"{deviceInfo}");
            }

            string ad4630BoardSessionStr = "{" +
                "\"session\": [ { \"service\": \"ad4630\" } ]," +
                "\"stream\": [ { \"service\": \"FTDI\", \"serialnumber\": \"FT8Y1ZJAA\" } ]," +
                "\"protocol\": [ { \"service\": \"CDPV1\" } ]," +
                "\"logger\": [ { \"service\": \"CONSOLE\" } ]," +
                "\"service\": [ { \"service\": \"RECV\" }, { \"service\": \"PARSE\" } ]" +
                "}";
            string dac11001BoardSessionStr = "{" +
                "\"session\": [ { \"service\": \"dac11001\" } ]," +
                "\"stream\": [ { \"service\": \"COM\", \"port\": \"COM5\",  \"baudrate\": \"115200\"} ]," +
                "\"protocol\": [ { \"service\": \"CDPV1\" } ]," +
                "\"logger\": [ { \"service\": \"CONSOLE\" } ]," +
                "\"service\": [ { \"service\": \"RECV\" }, { \"service\": \"PARSE\" } ]" +
                "}";
            string keysight3458ABoardSessionStr = "{" +
                "\"session\": [ { \"service\": \"3458a\" } ]," +
                "\"stream\": [ { \"service\": \"VISA\", \"address\": \"GPIB::22::INSTR\" } ]," +
                "\"protocol\": [ { \"service\": \"RAPV1\" } ]," +
                "\"logger\": [ { \"service\": \"CONSOLE\" } ]," +
                "\"service\": [  ]" +
                "}";

            var ad4630Session = SessionFactory.Current.CreateSession(ad4630BoardSessionStr, SessionConfig.Empty);
            var dac11001Session = SessionFactory.Current.CreateSession(dac11001BoardSessionStr, SessionConfig.Empty);
            var keysight3458ASession = SessionFactory.Current.CreateSession(keysight3458ABoardSessionStr, SessionConfig.Empty);


            int capturePoints = 1048576;
            int captureBytes = capturePoints * 4;

            byte[] data = new byte[captureBytes];
            int payloadLen = 0;

            ad4630Session.Services[1].Logging += (sender, args) =>
            {
                CdpDataPacket? packet = (args.Packet) as CdpDataPacket;
                if (packet is not null)
                {
                    //Console.WriteLine($"RECV CdpDataPacket: {packet}");
                    //Console.WriteLine(packet.Payload.BytesToHexString());
                    //using FileStream fs = new("D:/data.bin", FileMode.Append);
                    //fs.Write(packet.Payload);

                    //Buffer.BlockCopy(packet.Payload.ToArray(), 0, data, payloadLen, packet.Payload.Length);
                    var target = new Span<byte>(data, payloadLen, packet.Payload.Length);
                    packet.Payload.CopyTo(target);

                    payloadLen += packet.Payload.Length;
                }
                else
                {
                    Console.WriteLine("RECV MSGS");
                }
            };

            //ad4630Session.Open();
            dac11001Session.Open();
            //keysight3458ASession.Open();
            //keysight3458ASession.Write(new RawAsciiProtocolPacket("END"));
            //keysight3458ASession.Write(new RawAsciiProtocolPacket("ID?"));
            //keysight3458ASession.Read(out var pkts);
            //Console.WriteLine($"3458A: {pkts.First().Message}");
            //keysight3458ASession.Read(out pkts);
            //Console.WriteLine($"3458A: {pkts.First().Message}");
            //keysight3458ASession.Read(out pkts);
            //Console.WriteLine($"3458A: {pkts.First().Message}");
            dac11001Session.Write(new CdpMessagePacket("DAC11001.SET.VOLT;1.000000;"));

            int lenH = capturePoints / 0x10000;
            int lenL = capturePoints % 0x10000;
            Console.WriteLine($"CAPTURE {capturePoints}, REGH=0x{lenH:X4}, REGL=0x{lenL:X4}.");

            //for (int i = 0; i < 16; i++)
            //{

            //_ = keysight3458ASession.Read(bytes, 0, bytes.Length);
            //int cnt = keysight3458ASession.Read(bytes, 0, bytes.Length);
            // TODO
            ad4630Session.Write(new CdpRegisterPacket(0, 0, 0x06, 0x00));
            ad4630Session.Write(new CdpRegisterPacket(0, 0, 0x03, lenH));
            ad4630Session.Write(new CdpRegisterPacket(0, 0, 0x04, lenL));
            ad4630Session.Write(new CdpRegisterPacket(0, 0, 0x06, 0x01));

            while (payloadLen < captureBytes)
            {
                Console.WriteLine($"RECVING, Progress = {payloadLen}/{captureBytes}.");
                Thread.Sleep(250);
            }
            Console.WriteLine($"RECVING, Progress = {payloadLen}/{captureBytes}.");
            //}

            Console.WriteLine("DATA RECV COMPLETED");
            ad4630Session.Close();
            //dac11001Session.Close();
            keysight3458ASession.Close();

            return;
            /*
            //string testSession = "{" +
            //    "\"session\": [ { \"service\": \"session\", \"instance\": \"session1\" } ]," +
            //    "\"stream\": [ { \"service\": \"COM\", \"instance\": \"COM250\", \"baudrate\": \"115200\", \"databits\": \"8\", \"parity\": \"n\", \"stopbits\": \"1\" } ]," +
            //    "\"protocol\": [ { \"service\": \"RAPV1\", \"instance\": \"rapv1_inst1\" } ]," +
            //    "\"logger\": [ { \"service\": \"CONSOLE\", \"instance\": \"consolelogger_inst1\"} ]," +
            //    "\"service\": [ { \"service\": \"RECV\", \"instance\": \"recv_inst1\" }, { \"service\": \"PARSE\", \"instance\": \"parse_inst1\" } ]" +
            //    "}";

            string testSession = "{" +
                "\"session\": [ { \"service\": \"session\" } ]," +
                "\"stream\": [ { \"service\": \"VISA\", \"address\": \"TCPIP0::192.168.1.2::inst0::INSTR\", \"baudrate\": \"115200\", \"databits\": \"8\", \"parity\": \"n\", \"stopbits\": \"1\" } ]," +
                "\"protocol\": [ { \"service\": \"RAPV1\" } ]," +
                "\"logger\": [ { \"service\": \"CONSOLE\" } ]," +
                "\"service\": [ ]" +
                "}";

            var sc = SessionConfig.Create(testSession);
            foreach (var ll in sc.Components)
            {
                Console.WriteLine($"{ll.Type}::{ll.ServiceName}::{ll.InstanceName}::{SerializationHelper.SerializeToString(ll.Params)}");
            }
            return;

            // logger注册以及ioc模块日志创建object记录
            ProductProvider.Current.Container.RegisterInitializer<object>(
                (anyObj, resolver) => Console.WriteLine($"Object {{{anyObj}}} Resolved."));

            // 查找现有设备
            var deviceInfos = DriverFactory.Current.FindDevices();
            foreach (var deviceInfo in deviceInfos)
            {
                Console.WriteLine($"{deviceInfo}");
            }


            var s = SessionFactory.Current.CreateSession(
                testSession
                , SessionConfig.Empty);

            s.Open();

            Console.WriteLine("WRITE...");
            //s.Write(new("ABCDE".AsciiToBytes()));
            BatchWriter.RunFromFile(s, "D:\\Projects\\NB2408\\testcmd.txt", 100);
            byte[] rx = new byte[1024];
            for (int i = 0; i < 16; i++)
            {
                ///// INT
                //s.Write(new("*CLS\r\n".AsciiToBytes()));
                //Thread.Sleep(100);
                //s.Write(new("*TRG\r\n".AsciiToBytes()));
                //Thread.Sleep(100);
                //while (true)
                //{
                //    s.Write(new("*STB?\r\n".AsciiToBytes()));
                //    int len = s.Read(rx, 0, 1024);
                //    Console.WriteLine($"{rx.Take(len).ToArray().BytesToAscii().Replace("\n", "")}");
                //    if (len > 3)
                //        break;
                //    Thread.Sleep(100);
                //}
            }
            Console.WriteLine("COMPLETE REQUEST...");
            s.Close();

            Console.WriteLine("EXIT.");

            //DataRecvService service = new();
            //service.Run(serialStream, new RawAsciiProtocol());

            //byte[] b = [0x01, 0x02, 0x03, 0x04, 0x05];
            //s.Stream.Write(b, 0, 5);
            //Thread.Sleep(5000);
            //byte[] rdBuf = new byte[256];
            //var readLen = s.Stream.Read(rdBuf, 0, rdBuf.Length);
            //Console.WriteLine($"{readLen}");
            //s.Stream.Close();
            */
        }
    }

    /*
    Console.WriteLine("Press any key to start reading data...");
    Console.ReadKey();
    TcpListener listener = new TcpListener(new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8888));

    string ipAddress = "127.0.0.1"; // Example IP Address
    int port = 13000; // Example Port

    CustomProgress<int> progressReporter = new CustomProgress<int>(bytesReceived => Console.WriteLine($"Progress: Received {bytesReceived} bytes of data."));
    TcpStreamHandler tcpStreamHandler = new TcpStreamHandler(ipAddress, port, progressReporter);

    CancellationTokenSource cts = new CancellationTokenSource();
    Task readTask = tcpStreamHandler.StartReadingAsync(cts.Token);

    Console.WriteLine("Press any key to stop reading data...");
    Console.ReadKey();

    cts.Cancel();
    try
    {
        readTask.Wait(cts.Token); // Ensure any cleanup or final operations are completed
    }
    catch (Exception e)
    {
        if (e is OperationCanceledException)
        {
            Console.WriteLine($"Reading stopped. Total packets received: {tcpStreamHandler.TotalPacketsReceived}");
        }
    }
    */
    public class TcpStreamHandler
    {
        private TcpClient tcpClient;
        private NetworkStream networkStream;
        private int totalBytesRead = 0;
        private readonly CustomProgress<int> progress;
        public int TotalPacketsReceived { get; private set; } = 0;

        public TcpStreamHandler(string ipAddress, int port, CustomProgress<int> progress)
        {
            tcpClient = new TcpClient();
            tcpClient.ReceiveBufferSize = 1048576;
            IPEndPoint ipEp = new IPEndPoint(IPAddress.Parse(ipAddress), port);
            tcpClient.Connect(ipEp);
            networkStream = tcpClient.GetStream();
            this.progress = progress;
        }

        public async Task StartReadingAsync(CancellationToken cancellationToken)
        {
            try
            {
                byte[] buffer = new byte[4096];
                while (!cancellationToken.IsCancellationRequested)
                {
                    int bytesRead = await networkStream.ReadAsync(buffer, 0, buffer.Length, cancellationToken);
                    if (bytesRead > 0)
                    {
                        totalBytesRead += bytesRead;
                        progress?.Report(totalBytesRead);
                        UnpackData(buffer, bytesRead);
                    }
                }
            }
            catch (Exception ex) when (ex is not OperationCanceledException)
            {
                Console.WriteLine($"An error occurred: {ex.Message}");
            }
        }

        private int UnpackData(byte[] data, int bytesRead)
        {
            int packets = bytesRead / 2;
            TotalPacketsReceived += bytesRead;
            for (int i = 0; i < packets; i++)
            {
                byte[] packet = new byte[2];
                Array.Copy(data, i * 2, packet, 0, 2);
                // Process each packet here
                //Console.WriteLine($"Packet {i + 1}/{packets}: {BitConverter.ToString(packet)}");
            }
            return packets;
        }
    }

    public class CustomProgress<T> : IProgress<T>
    {
        private readonly Action<T> action;

        public CustomProgress(Action<T> action)
        {
            this.action = action;
        }

        public void Report(T value)
        {
            action?.Invoke(value);
        }
    }
}


